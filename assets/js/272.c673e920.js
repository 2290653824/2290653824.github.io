(window.webpackJsonp=window.webpackJsonp||[]).push([[272],{594:function(v,_,t){"use strict";t.r(_);var o=t(4),l=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("ol",[_("li",[v._v("实习中遇到了什么深刻的问题")])]),v._v(" "),_("p",[v._v("聊到了数据库增量数据迁移的一些问题")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("实习过程中收获了什么东西")])]),v._v(" "),_("p",[v._v("技术方面、非技术方面")]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("面向对象的特征，多态项目中实际的应用")]),v._v(" "),_("li",[v._v("面向对象的基本原则")])]),v._v(" "),_("p",[v._v("其实就是设计模式的几大原则，我服了没答出来")]),v._v(" "),_("ol",{attrs:{start:"5"}},[_("li",[v._v("构造方法可以被重载吗 - 可以；构造方法可以被重写吗- 不能")]),v._v(" "),_("li",[v._v("abstract和static可以在同一个方法上被使用吗")])]),v._v(" "),_("blockquote",[_("p",[v._v("在 Java 中，"),_("code",[v._v("abstract")]),v._v(" 和 "),_("code",[v._v("static")]),v._v(" 这两个关键字不能同时用于同一个方法。这是因为它们具有不同的语义和行为，导致它们无法同时出现在同一个方法声明中。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("abstract")]),v._v(" 方法是指在父类中声明但没有实现的方法，要求子类必须提供具体的实现。抽象方法没有方法体，只有方法签名。抽象方法必须在抽象类中声明。")]),v._v(" "),_("li",[_("code",[v._v("static")]),v._v(" 方法是指属于类而不是实例的方法。它们可以直接通过类名来调用，而无需先创建类的实例。静态方法通常用于实现与类本身相关的功能，而不涉及特定对象的状态。")])]),v._v(" "),_("p",[v._v("因为抽象方法要求子类提供具体的实现，而静态方法是与类而非实例相关的，将这两者合并到同一个方法是没有实际意义的，也与它们各自的目的相违背。因此，在 Java 中，不能将 "),_("code",[v._v("abstract")]),v._v(" 和 "),_("code",[v._v("static")]),v._v(" 同时应用于同一个方法。")])]),v._v(" "),_("ol",{attrs:{start:"7"}},[_("li",[_("p",[v._v("实习的项目当中有没有使用到集合或者什么算法之类的。")])]),v._v(" "),_("li",[_("p",[v._v("浏览器中输入一个网址，后续流程是怎么走的")])]),v._v(" "),_("li",[_("p",[v._v("在网络传递过程中，mac地址扮演了怎么样的角色")])])]),v._v(" "),_("blockquote",[_("p",[v._v("在网络传递过程中，MAC 地址（Media Access Control 地址）扮演着重要的角色。MAC 地址是网络设备（如计算机、网络适配器、路由器等）网卡上的唯一标识符，用于在局域网（LAN）中识别设备。以下是 MAC 地址在网络传递过程中的几个关键角色：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("唯一标识设备")]),v._v("：每个网络设备都有一个唯一的 MAC 地址，它类似于身份证号码，用于在局域网中标识和区分不同的设备。这有助于确保数据包被正确地传送到目标设备。")]),v._v(" "),_("li",[_("strong",[v._v("数据链路层寻址")]),v._v("：在 OSI 模型的数据链路层（第二层），数据帧是通过 MAC 地址进行寻址的。当数据从源设备发送到目标设备时，数据帧中包含了源设备和目标设备的 MAC 地址。网络设备通过比较目标 MAC 地址来判断是否接收这个数据帧。")]),v._v(" "),_("li",[_("strong",[v._v("局域网内通信")]),v._v("：在同一局域网内，设备之间的通信是基于 MAC 地址的。当一个设备需要与另一个设备通信时，它可以将数据包发送到目标设备的 MAC 地址，而不必关心远程目标设备的 IP 地址。")]),v._v(" "),_("li",[_("strong",[v._v("ARP 协议")]),v._v("：在 IP 地址到 MAC 地址的映射方面，ARP（Address Resolution Protocol）扮演着重要角色。当一个设备知道目标的 IP 地址但不知道其对应的 MAC 地址时，它会发送 ARP 请求广播，询问谁拥有特定 IP 地址的 MAC 地址。目标设备会回应这个请求，将其 MAC 地址发送给请求者，以便建立正确的映射关系。")])]),v._v(" "),_("p",[v._v("总之，MAC 地址在局域网内的数据帧传递、设备识别和 ARP 协议中发挥着关键作用。但需要注意的是，在不同的局域网之间（不同的子网），通信是通过路由器和 IP 地址来进行的，而不是直接通过 MAC 地址。")])]),v._v(" "),_("p",[v._v("没有答到在局域网内唯一标识一台设备。答了ARP协议")]),v._v(" "),_("ol",{attrs:{start:"10"}},[_("li",[v._v("对netty的了解。")]),v._v(" "),_("li",[v._v("拆包和粘包是什么？怎么解决拆包和粘包的问题。")])]),v._v(" "),_("blockquote",[_("ol",[_("li",[_("strong",[v._v("拆包（Packet Splitting）")]),v._v("：拆包是指发送端将一次性的数据分割成多个小包进行发送，而接收端在接收数据时可能会将这些小包当作独立的消息进行处理。这可能导致接收端得到的数据包不完整，造成数据解析错误。")]),v._v(" "),_("li",[_("strong",[v._v("粘包（Packet Pasting）")]),v._v("：粘包是指发送端将多个消息封装成一个大的数据包进行发送，接收端在接收数据时可能会将多个消息组合在一起，导致解析时出现混乱。")])]),v._v(" "),_("p",[v._v("这些问题的产生是因为底层的 TCP 协议是面向流的，它负责将数据分割成合适的数据包并传输，但并不保证数据包与应用层消息的一一对应。")]),v._v(" "),_("p",[v._v("为了解决拆包和粘包问题，可以采取以下方法：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("定长消息")]),v._v(": 发送端在发送消息前，将消息固定长度填充，使得每个消息的长度都是固定的。接收端可以按照固定长度来解析消息。")]),v._v(" "),_("li",[_("strong",[v._v("分隔符消息")]),v._v(": 发送端在消息之间插入特定的分隔符，接收端通过分隔符来识别消息的边界。这种方法需要选择一个不会在消息内容中出现的分隔符。")]),v._v(" "),_("li",[_("strong",[v._v("消息长度字段")]),v._v(": 在消息头部添加一个字段，表示整个消息的长度。接收端首先读取长度字段，然后按照指定长度读取剩余的数据，从而精确地分割消息。")]),v._v(" "),_("li",[_("strong",[v._v("应用层协议")]),v._v(": 在应用层设计专门的协议来管理消息的分割和合并，确保消息按照预定的格式进行传输。")]),v._v(" "),_("li",[_("strong",[v._v("使用换行符")]),v._v(": 如果应用允许，可以在消息末尾添加换行符（例如 '\\n'）作为分隔符，这在文本协议中比较常见。")]),v._v(" "),_("li",[_("strong",[v._v("使用专门的库或框架")]),v._v(": 一些网络通信库或框架（例如 Netty）提供了解决拆包和粘包问题的机制，可以减轻开发人员的负担。")])]),v._v(" "),_("p",[v._v("总之，解决拆包和粘包问题需要根据具体情况选择合适的方法，并在通信协议设计中充分考虑这些问题，以确保数据的正确传输和解析。")])]),v._v(" "),_("ol",{attrs:{start:"12"}},[_("li",[v._v("sleep(0) 有什么用")])]),v._v(" "),_("blockquote",[_("p",[v._v("Thread.Sleep(0)的作用，就是“"),_("strong",[v._v("触发操作系统立刻重新进行一次CPU竞争")]),v._v("”。 竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。")])]),v._v(" "),_("p",[v._v("https://developer.aliyun.com/article/37928")]),v._v(" "),_("p",[v._v("yiel:在Java中，Thread类中的yield()方法"),_("strong",[v._v("用于将CPU 资源让给其他线程")]),v._v("。 当一个线程调用yield()方法时，它会暂停当前正在执行的任务并让出CPU资源，以便其他线程有机会执行。 如果没有其他线程需要执行，那么该线程将继续执行")]),v._v(" "),_("p",[v._v("所以sleep(0)和yield() 有什么区别？TODO")]),v._v(" "),_("ol",{attrs:{start:"13"}},[_("li",[v._v("实习或项目中有没有并发的场景")])]),v._v(" "),_("p",[v._v("还需要打造")]),v._v(" "),_("ol",{attrs:{start:"14"}},[_("li",[v._v("volatile 关键字的作用？可以保证原子性吗？")])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("volatile")]),v._v(" 关键字可以保证变量的可见性和有序性，但不能保证操作的原子性。在多线程环境下，多个线程可能同时访问和修改同一个 "),_("code",[v._v("volatile")]),v._v(" 变量，而且 "),_("code",[v._v("volatile")]),v._v(" 变量的修改不会被缓存，而是直接从主内存中读取或写入。")]),v._v(" "),_("p",[v._v("原子性是指一个操作是不可中断的，要么全部执行成功，要么全部不执行，没有中间状态。"),_("code",[v._v("volatile")]),v._v(" 修饰的变量在读取和写入时不会发生线程切换或中断，但对于复合操作（例如递增操作）可能会发生竞态条件，导致不一致的结果。")]),v._v(" "),_("p",[v._v("如果需要确保某个操作的原子性，可以使用 "),_("code",[v._v("java.util.concurrent")]),v._v(" 包中提供的原子类，比如 "),_("code",[v._v("AtomicInteger")]),v._v("、"),_("code",[v._v("AtomicLong")]),v._v(" 等。这些原子类提供了一系列原子操作，可以保证在多线程环境下执行这些操作时不会发生竞态条件，从而保证原子性。")]),v._v(" "),_("p",[v._v("总结起来，"),_("code",[v._v("volatile")]),v._v(" 可以保证可见性和有序性，但不足以保证复合操作的原子性。对于需要保证原子性的操作，应该使用适当的同步机制，如 "),_("code",[v._v("synchronized")]),v._v(" 块或 "),_("code",[v._v("java.util.concurrent")]),v._v(" 包中的原子类。")])]),v._v(" "),_("p",[v._v("https://www.zhihu.com/question/329746124")]),v._v(" "),_("ol",{attrs:{start:"15"}},[_("li",[v._v("出现了bug，你有哪些思路来排查bug。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);