(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{409:function(t,e,s){"use strict";s.r(e);var v=s(4),_=Object(v.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"记忆集-remember-set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#记忆集-remember-set"}},[t._v("#")]),t._v(" 记忆集 Remember Set")]),t._v(" "),e("p",[t._v("why 为什么用记忆集")]),t._v(" "),e("ul",[e("li",[t._v("跨带引用")])]),t._v(" "),e("p",[t._v("老年代中的对象可能引用了新生代中的对象")]),t._v(" "),e("p",[t._v("那么在进行young gc时，我们通过gc roots在新生代中找到了对应需要保留的对象，而其他的对象可能部分是被老年代引用的，这些对象需要被保留，但是新生代的gc roots并没有扫描到。")]),t._v(" "),e("p",[t._v("解决方法：")]),t._v(" "),e("ol",[e("li",[t._v("扫描老年代的对象，查看是否有跨带引用的对象（缺点：还需要对老年代进行扫描，效率太低）")]),t._v(" "),e("li",[t._v("使用记忆集：在新生代这边的内存区域维护一个记忆集，这个记忆集中存放了老年代中跨带引用对象的引用，当进行gc roots标记时，记忆集中的对象也会开始寻找关联对象。")])]),t._v(" "),e("h3",{attrs:{id:"什么是卡表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是卡表"}},[t._v("#")]),t._v(" 什么是卡表")]),t._v(" "),e("p",[t._v("卡表 Cardtable：jdk中记忆集的具体实现")]),t._v(" "),e("p",[t._v("卡表有两个概念 卡页、卡表")]),t._v(" "),e("p",[t._v("卡页：在老年代中没512byte字节为一个卡页，一些对象就分配在卡页中")]),t._v(" "),e("p",[t._v("卡表：年轻代维护的一个数组，里面存放对应卡页是否为脏页和对应的卡页起始位置。")]),t._v(" "),e("p",[t._v("当老年代分批对象时，一旦某一个卡页中出现了脏页，则会在年青代中卡表对应的节点置为1；")]),t._v(" "),e("p",[t._v("当进行垃圾年青代垃圾清楚时，扫描卡表检查是否有脏页，有的话，则对脏页进行扫描检查跨代引用")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20230811210810622.png",alt:"image-20230811210810622"}})])])}),[],!1,null,null,null);e.default=_.exports}}]);