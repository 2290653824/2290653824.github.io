(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{479:function(t,s,a){"use strict";a.r(s);var n=a(4),v=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"一-重复消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-重复消费"}},[t._v("#")]),t._v(" 一.重复消费")]),t._v(" "),s("p",[t._v("产生原因，大多数的消息队列都有消息重新发送的机制。当一个消费者消费一个消息时，肯呢个会出现服务的"),s("strong",[t._v("网络抖动")]),t._v("，"),s("strong",[t._v("开发人员代码Bug")]),t._v("，还有"),s("strong",[t._v("数据问题")]),t._v("等都可能处理失败要求重发的。")]),t._v(" "),s("p",[t._v("听起来没有问题，但是万一多个服务监听一个消息呢？一个服务挂了，要求重发，那么该服务成功消费一次，但是其他服务会消费两次该服务，这就是重复消费。")]),t._v(" "),s("p",[t._v("解决方案：")]),t._v(" "),s("p",[t._v("一.前端保证")]),t._v(" "),s("ol",[s("li",[t._v("前端保证幂等性的方法按钮只能点击一次用户点击按钮后将按钮置灰，或者显示loading状态")]),t._v(" "),s("li",[t._v("RPG模式：即Post-Redirect-Get，当客户提交"),s("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E8%A1%A8%E5%8D%95&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("表单"),s("OutboundLink")],1),t._v("后，去执行一个客户端的重定向，转到提交成功页面。避免用户按F5刷新导致的重复提交，也能消除按浏览器后退键导致的重复提交问题。目前绝大多数公司都是这样做的，比如淘宝，京东等")])]),t._v(" "),s("p",[t._v("二.后端保证")]),t._v(" "),s("p",[s("strong",[t._v("接口幂等：")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。\n\n在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。\n\n幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。\n\n例如，“"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTrue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("”函数就是一个幂等函数"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("无论多次执行，其结果都是一样的"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("更复杂的操作幂等保证是利用唯一交易号"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("流水号"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("实现"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/29475739/1667742392409-645cd4e8-bb14-44a8-9c69-59f3d97b1c5f.png",alt:"img"}})]),t._v(" "),s("p",[t._v("怎么保证幂等性？")]),t._v(" "),s("p",[t._v("分为强校验（重要逻辑，设计金额）和弱校验（不是关键逻辑）")]),t._v(" "),s("ol",[s("li",[t._v("全局唯一id实现幂等性")])]),t._v(" "),s("p",[s("strong",[t._v("强校验：")])]),t._v(" "),s("p",[t._v("适用于一些比较重要的场景，比如涉及金额相关的操作")]),t._v(" "),s("p",[t._v("通常会用订单号+业务场景 这样的唯一标识去查流水表，查到就直接返回（其他消费者重复消费到一个消费者），没有查到才去真正走一个逻辑（当前消费者因为上一个消息丢失了，现在因重复发送收到了一个真正的消息）")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/29475739/1667742502331-5378193d-fa15-4cf7-9304-c5f69fc70a4f.png",alt:"img"}})]),t._v(" "),s("p",[t._v("https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453140974&idx=1&sn=22ee07f493f029f9ac8ae19266d14283&scene=21#wechat_redirect")]),t._v(" "),s("p",[s("strong",[t._v("弱校验")])]),t._v(" "),s("p",[s("strong",[t._v("用在不是很重要的场景，如短信发送的逻辑。")])]),t._v(" "),s("p",[t._v("这个简单，一些不重要的场景，比如给谁发短信啥的，我就把这个id+场景唯一标识作为"),s("strong",[t._v("Redis")]),t._v("的key，放到缓存里面失效时间看你场景，"),s("strong",[t._v("一定时间内")]),t._v("的这个消息就去Redis判断。（redis+LRU实现滑动窗口限流）")]),t._v(" "),s("p",[t._v("用KV就算消息丢了可能这样的场景也没关系，反正丢条"),s("strong",[t._v("无关痛痒")]),t._v("的通知短信嘛（你敢说你没验证码短信丢失的情况？）。")]),t._v(" "),s("h2",{attrs:{id:"二-顺序消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-顺序消费"}},[t._v("#")]),t._v(" 二.顺序消费")]),t._v(" "),s("p",[t._v("介绍：一般都是"),s("strong",[t._v("同个业务场景下不同几个操作的消息同时过去")]),t._v("，本身顺序是对的，但是你发出去的时候同时发出去了，消费的时候却乱掉了，这样就有问题了。")]),t._v(" "),s("p",[t._v("比如在一个大并发量操作数据库的情况下，我们将一些操作放到消息列表中实现高峰削谷。但是如果我们以一定的顺序放到队列中，但是被消费者消费时如果不是一个顺序的话，可能会造成很多的问题。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/29475739/1667784232183-c1179166-8784-451f-a501-0ae747336b30.png",alt:"img"}})]),t._v(" "),s("p",[t._v("解决方案：不同的消息队列的具体实现不同，中间件可能会保证队列中小消息顺序，消费者也应该保证消息的消息顺序")]),t._v(" "),s("p",[t._v("在kafka中如何保证顺序性？https://blog.csdn.net/java_atguigu/article/details/123920233")]),t._v(" "),s("h2",{attrs:{id:"三-分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三-分布式事务"}},[t._v("#")]),t._v(" 三. 分布式事务")]),t._v(" "),s("p",[t._v("与单节点的事务不同。就拿消息队列来说，不同的消费者可能会去消费不同的消息，那么一个消费者成功了，另一个消费者失败了，那是不是不满足事务应该进行回滚呢？但是对于非单节点的分布式来说，拿我们以前的Transactional已经无法解决问题了。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/29475739/1667784595941-08de094d-593e-4c7b-9540-70eda952abc9.png",alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"四-消息丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四-消息丢失"}},[t._v("#")]),t._v(" 四.消息丢失")]),t._v(" "),s("p",[t._v("可能因为网络原因造成消息丢失，或因为事务原因导致一个消息没有被正确消费")])])}),[],!1,null,null,null);s.default=v.exports}}]);