(window.webpackJsonp=window.webpackJsonp||[]).push([[325],{648:function(s,a,t){"use strict";t.r(a);var n=t(4),e=Object(n.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"一-背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-背景"}},[s._v("#")]),s._v(" 一. 背景")]),s._v(" "),a("p",[s._v("在我们平常的开发当中，我们想要测试不同jdk版本之间的一些新功能时，需要去切换jdk的版本，这个时候又需要去对应的环境变量中进行配置JAVA_HOME。但其实如果我们手动去更新的话，其实很麻烦。为了提供效率，我们可以写一个脚本，来更新我们的jdk版本。")]),s._v(" "),a("h2",{attrs:{id:"二-shell脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-shell脚本"}},[s._v("#")]),s._v(" 二. shell脚本")]),s._v(" "),a("p",[s._v("前提：将对应的jdk目录放到/usr/local/下，例如：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/image-20231016105307013.png",alt:"image-20231016105307013"}})]),s._v(" "),a("p",[s._v("①创建文件： source jdk_change.sh")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("#"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("bin"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("bash\n\n# 设置"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JDK")]),s._v("安装目录\njdk_dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/usr/local"')]),s._v("\n\n# 设置可用的"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JDK")]),s._v("版本和路径\ndeclare "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("A")]),s._v(" jdk_versions\njdk_versions"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"jdk8"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("$jdk_dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("jdk8\njdk_versions"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"jdk11"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("$jdk_dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("jdk11\njdk_versions"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"jdk17"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("$jdk_dir"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("jdk17\n\n# 打印可用的"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JDK")]),s._v("版本\necho "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"可用的JDK版本:"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" version in "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${!jdk_versions[@]}"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("do")]),s._v("\n    echo "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"$version"')]),s._v("\ndone\n\n# 提示用户输入要切换的"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JDK")]),s._v("版本\nread "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("p "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"请输入要切换的JDK版本: "')]),s._v(" selected_version\n\n# 检查用户输入的版本是否存在\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${jdk_versions[@]}"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("~")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${selected_version}"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" then\n    echo "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"无效的JDK版本!"')]),s._v("\n    exit "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nfi\n\n# 设置新的"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JAVA_HOME")]),s._v("和"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("PATH")]),s._v("\nexport "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JAVA_HOME")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${jdk_versions[$selected_version]}"')]),s._v("\nexport "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("PATH")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"$JAVA_HOME/bin:$PATH"')]),s._v("\n\n# 打印切换后的"),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("JDK")]),s._v("版本\necho "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"已切换至JDK版本: $selected_version"')]),s._v("\njava "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("version\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br")])]),a("p",[s._v("②执行文件\n"),a("code",[s._v("source jdk_cahnge.sh")])]),s._v(" "),a("p",[s._v("③注意事项：\n上面的方法只能更改当前会话内的jdk环境变量，当我们重新通过ssh建立连接后，需要重新执行上面的脚本才可以生效。")]),s._v(" "),a("h2",{attrs:{id:"三-相关知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-相关知识点"}},[s._v("#")]),s._v(" 三. 相关知识点")]),s._v(" "),a("h3",{attrs:{id:"_1-什么是bash和shell"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是bash和shell"}},[s._v("#")]),s._v(" 1. 什么是bash和shell")]),s._v(" "),a("p",[a("strong",[s._v("①shell")]),s._v("\nshell是用户和Linux（或者更准确的说，是用户和Linux内核）之间的接口程序。你在提示符下输入的每个命令都由shell先解释然后传给Linux内核。\nshell 是一个命令语言解释器（command-language interpreter）。拥有自己内建的 shell 命令集。此外，shell也能被系统中其他有效的Linux 实用程序和应用程序（utilities and application programs）所调用。\n不论何时你键入一个命令，它都被Linux shell所解释。一些命令，比如打印当前工作目录命令（pwd），是包含在Linux bash内部的（就象DOS的内部命令）。其他命令，比如拷贝命令（cp）和移动命令（rm），是存在于文件系统中某个目录下的单独的程序。而对用户来说，你不知道（或者可能不关心）一个命令是建立在shell内部还是一个单独的程序。")]),s._v(" "),a("ul",[a("li",[s._v("首先检查命令是否是内部命令")]),s._v(" "),a("li",[s._v("不是的话再检查是否是一个应用程序，这里的应用程序可以是Linux本身的实用程序，比如ls rm，")]),s._v(" "),a("li",[s._v("然后shell试着在搜索路径($PATH)里寻找这些应用程序。搜索路径是一个能找到可执行程序的目录列表。")])]),s._v(" "),a("blockquote",[a("p",[s._v("如果你键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。而如果命令被成功的找到的话，shell的内部命令或应用程序将被分解为系统调用并传给Linux内核。")])]),s._v(" "),a("p",[a("strong",[s._v("②bash")]),s._v("\nBourne Again shell (bash), 正如它的名字所暗示的，是 Bourne shell 的扩展。bash 与 Bourne shell 完全向后兼容，并且在 Bourne shell 的基础上增加和增强了很多特性。bash 也包含了很多 C 和 Korn shell 里的优点。bash 有很灵活和强大的编程接口，同时又有很友好的用户界面。\n为什么要用 bash 来代替 sh 呢？Bourne shell 最大的缺点在于它处理用户的输入方面。在 Bourne shell 里键入命令会很麻烦，尤其当你键入很多相似的命令时。而 bash 准备了几种特性使命令的输入变得更容易。\n这是几个最有用的bash内部命令：\nalias: 设置bash别名。\nbg: 使一个被挂起的进程在后台继续执行。\ncd: 改变当前工作目录。\nexit: 终止shell。\nexport: 使变量的值对当前shell的所有子进程都可见 。\nfc: 用来编辑历史命令列表里的命令。\nfg: 使一个被挂起的进程在前台继续执行。\nhelp: 显示bash内部命令的帮助信息。\nkill: 终止某个进程。\npwd: 显示当前工作目录。\nunalias: 删除已定义的别名。")]),s._v(" "),a("blockquote",[a("p",[s._v("所以我们执行sh xx.sh和bash xx.sh时，sh执行有时候会出现command not found找不到命令的报错，其实就是因为可能shell脚本里面有些命令是bash独有的，所以找不到，这个时候我们换成bash xx.sh来执行就可以了。例如declare命令就是bash独有的")])]),s._v(" "),a("h3",{attrs:{id:"_2-命令bash和source有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-命令bash和source有什么区别"}},[s._v("#")]),s._v(" 2. 命令bash和source有什么区别")]),s._v(" "),a("ol",[a("li",[s._v("执行环境：source 命令在当前 Shell 环境中执行指定的脚本文件，而不会创建新的进程。这意味着脚本中的命令和设置会直接影响当前 Shell 环境，包括环境变量、函数定义、别名等。相反，bash 命令会创建一个新的 Bash Shell 进程，并在该进程中执行指定的脚本文件。脚本中的命令和设置只会影响新创建的进程，不会对当前 Shell 环境产生影响。")]),s._v(" "),a("li",[s._v("脚本路径：source 命令需要提供脚本文件的路径，并且该文件需要具有可执行权限。它会将指定的脚本文件作为当前 Shell 环境的一部分来执行。相比之下，bash 命令不要求脚本文件具有可执行权限，只需要提供脚本文件的路径即可。")]),s._v(" "),a("li",[s._v("脚本类型：source 命令主要用于执行 Bash 脚本文件（.sh），它是 Bash Shell 的内置命令。它会使用当前 Shell 解释器来执行脚本文件。而 bash 命令可以用于执行任何类型的脚本文件，包括 Bash 脚本、Shell 脚本以及其他脚本语言（如Python脚本、Perl脚本等）。它会创建一个新的 Bash Shell 进程来解释和执行脚本文件。")])]),s._v(" "),a("blockquote",[a("p",[s._v("这也就是我们执行xx.sh时，如果里面有声明环境变量export时，如果我们使用bash，是无法在外面生效的原因，而执行source才能使当前连接的环境变量真正生效。")])]),s._v(" "),a("h3",{attrs:{id:"_3-etc-profile文件和我们手动执行source-sh文件有什么区别吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-etc-profile文件和我们手动执行source-sh文件有什么区别吗"}},[s._v("#")]),s._v(" 3.  /etc/profile文件和我们手动执行source sh文件有什么区别吗")]),s._v(" "),a("p",[s._v("/etc/profile 文件是系统级别的配置文件，用于设置全局的环境变量和执行系统范围的初始化操作。当登录到系统时，无论是以交互方式登录还是通过远程连接登录，"),a("strong",[s._v("系统都会读取并执行 /etc/profile 文件")]),s._v("。")]),s._v(" "),a("p",[s._v("而执行 source 命令来加载一个脚本文件时，该脚本文件通常是用户级别的，是特定用户为了满足自己的需求而创建的。用户可以在自己的脚本文件中定义和修改环境变量，以及执行其他个性化的设置。")]),s._v(" "),a("p",[s._v("主要区别如下：")]),s._v(" "),a("ol",[a("li",[s._v("范围：/etc/profile 文件中定义的环境变量是系统级别的，适用于所有用户，影响整个系统。而通过 source 命令加载的脚本文件中定义的环境变量是用户级别的，仅对当前用户有效。")]),s._v(" "),a("li",[s._v("权限：/etc/profile 文件通常由系统管理员管理和维护，因此需要相应的权限才能进行修改。而用户可以在自己的目录下创建脚本文件，并通过 source 命令加载，无需特殊权限。")]),s._v(" "),a("li",[s._v("优先级：当用户登录时，系统首先会执行 /etc/profile 文件，然后再执行用户的个人配置文件（如 ~/.bash_profile、~/.bashrc 等）。因此，在执行用户级别的脚本文件时，可以覆盖 /etc/profile 文件中定义的环境变量或进行个性化设置。")])]),s._v(" "),a("p",[s._v("总之，/etc/profile 文件是系统级别的配置文件，用于设置全局的环境变量和执行系统范围的初始化操作。而通过 source 命令加载的个人脚本文件是用户级别的，用于定义用户特定的环境变量和执行个性化设置。")]),s._v(" "),a("p",[s._v("参考：\n"),a("a",{attrs:{href:"https://blog.csdn.net/lizhidefengzi/article/details/74066590",target:"_blank",rel:"noopener noreferrer"}},[s._v("什么是Bash、什么是shell？"),a("OutboundLink")],1)]),s._v(" "),a("blockquote",[a("p",[s._v("这个解答，解决了为什么我们手动执行xxx.sh里面的环境变量在其他的连接不生效的原因，因为其他ssh连接成果时，会自动执行/etc/profile文件。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);