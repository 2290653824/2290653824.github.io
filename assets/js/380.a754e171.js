(window.webpackJsonp=window.webpackJsonp||[]).push([[380],{705:function(t,v,_){"use strict";_.r(v);var a=_(4),r=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"ci-持续集成"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ci-持续集成"}},[t._v("#")]),t._v(" CI 持续集成")]),t._v(" "),v("p",[t._v("Continuous Integration")]),t._v(" "),v("p",[t._v("概念：频繁地（一天多次）将本地代码提交合并集成到主分支")]),t._v(" "),v("p",[t._v("优点：")]),t._v(" "),v("ul",[v("li",[t._v("**快速发现错误。**每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。")]),t._v(" "),v("li",[t._v("**防止分支大幅偏离主干。**如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。")])]),t._v(" "),v("p",[t._v("这样可以让产品进行快速的迭代，同时保持高质量。")]),t._v(" "),v("p",[t._v("在CI的过程中，开发人员将代码提交到主干过前，通过CI工具自动地对代码进行自动化2测试，只要一个测试不通过，就不能进行集成。通过此方法可以快速反馈给开发人员发现相关bug并进行改正。")]),t._v(" "),v("p",[t._v("采用持续集成时，开发人员可以使用诸如 Git 之类的版本控制系统，将更新频繁提交到共享存储库中。在每次提交前，开发人员可以选择在集成前对其代码执行本地单元测试，作为额外的验证层。持续集成服务在新代码更改上自动构建和运行单元测试，以立即发现任何错误。")]),t._v(" "),v("p",[v("em",[t._v("持续集成是指软件发布流程的构建和单元测试阶段。提交的每一个修订都会触发自动化的构建和测试操作。")])]),t._v(" "),v("h2",{attrs:{id:"cd持续交付"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cd持续交付"}},[t._v("#")]),t._v(" CD持续交付")]),t._v(" "),v("p",[t._v("**持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。**如果评审通过，代码就进入生产阶段。")]),t._v(" "),v("p",[t._v("持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。")]),t._v(" "),v("h2",{attrs:{id:"持续部署"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#持续部署"}},[t._v("#")]),t._v(" 持续部署")]),t._v(" "),v("p",[v("strong",[t._v("持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。")])]),t._v(" "),v("p",[t._v("持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。")]),t._v(" "),v("p",[t._v("持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230124104500093.png",alt:"image-20230124104500093"}})]),t._v(" "),v("h2",{attrs:{id:"流程简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#流程简介"}},[t._v("#")]),t._v(" 流程简介")]),t._v(" "),v("ol",[v("li",[t._v("提交commit")])]),t._v(" "),v("p",[t._v("开发者向代码仓库提交代码")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("测试（第一轮）")])]),t._v(" "),v("p",[t._v("代码仓库配置钩子函数hook，一旦对代码仓库提交代码或者合并主干操作，就会执行钩子函数，进行自动化测试")]),t._v(" "),v("p",[t._v("测试的种类：")]),t._v(" "),v("ul",[v("li",[t._v("单元测试：针对函数或者模块的测试")]),t._v(" "),v("li",[t._v("集成测试：针对整体产品的某个功能的测试，又称为功能测试")]),t._v(" "),v("li",[t._v("端对端测试：从用户界面直达数据库的全链路测试")])]),t._v(" "),v("p",[t._v("第一轮测试至少要进行单元测试")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("构建build")])]),t._v(" "),v("p",[t._v("此时第一次的测试已经进行完毕，代码已经合并到了仓库的主干。")]),t._v(" "),v("p",[t._v("交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。")]),t._v(" "),v("p",[t._v("常见的构件工具：Jenkins、Travis、Codeship、Strider")]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("测试（第二轮）")])]),t._v(" "),v("p",[t._v("构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。")]),t._v(" "),v("p",[t._v("第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。")]),t._v(" "),v("p",[t._v("需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。")]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("部署")])]),t._v(" "),v("p",[t._v("通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ "),v("code",[t._v("tar filename.tar *")]),t._v(" ）存档，发到生产服务器。")]),t._v(" "),v("p",[t._v("生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有"),v("a",{attrs:{href:"https://www.ansible.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Ansible"),v("OutboundLink")],1),t._v("，"),v("a",{attrs:{href:"https://www.chef.io/chef/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Chef"),v("OutboundLink")],1),t._v("，"),v("a",{attrs:{href:"https://puppetlabs.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Puppet"),v("OutboundLink")],1),t._v("等。")]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("回滚")])]),t._v(" "),v("p",[t._v("一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。")]),t._v(" "),v("h2",{attrs:{id:"如何使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何使用"}},[t._v("#")]),t._v(" 如何使用")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230407192226754.png",alt:"image-20230407192226754"}})]),t._v(" "),v("p",[t._v("jenkins")]),t._v(" "),v("p",[t._v("官网下载：")]),t._v(" "),v("p",[t._v("如果本地下载了java，可以直接下载java的war包")]),t._v(" "),v("p",[t._v("运行war包")]),t._v(" "),v("p",[t._v("复制密码")]),t._v(" "),v("p",[t._v("访问localhost:8080")]),t._v(" "),v("p",[t._v("下载推荐插件")]),t._v(" "),v("p",[t._v("创建管理用户")]),t._v(" "),v("p",[t._v("我们启动的这个程序可以看作git过程中的服务器")]),t._v(" "),v("p",[t._v("构建触发器")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230407192818981.png",alt:"image-20230407192818981"}})]),t._v(" "),v("p",[t._v("通过shell进行构建")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230407192858383.png",alt:"image-20230407192858383"}})]),t._v(" "),v("p",[t._v("原理：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("本地提交到远程仓库入github，github通过hock函数调用一个公网ip，公网中的jkens将代码拉取，并执行shell中的内容。")])]),t._v(" "),v("li",[v("p",[t._v("本地提交到远程仓库入github，死亡定时检查github是否更新，如果检查到更新，则拉取代码，并执行shell中的内容。")])])]),t._v(" "),v("p",[t._v("travis - github")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://travis-ci-org",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://travis-ci-org"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("该网站可以和github同步数据。同步过后，需要在github对应的项目的路径下，创建名为"),v("code",[t._v(".travis.yml")]),t._v("的执行脚本文件。")]),t._v(" "),v("p",[t._v("以上都是持续集成的流程")]),t._v(" "),v("p",[t._v("下面是持续交付")]),t._v(" "),v("p",[t._v("doucloud 与cicd于一身")]),t._v(" "),v("p",[t._v("mvn test是什么")]),t._v(" "),v("p",[t._v("最适合的工具github actions\n1\n官方文档："),v("a",{attrs:{href:"https://docs.github.com/en/actions/using-workflows/about-workflows",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://docs.github.com/en/actions/using-workflows/about-workflows"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=r.exports}}]);