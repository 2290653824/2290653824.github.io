(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{480:function(s,a,t){"use strict";t.r(a);var e=t(4),n=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("投递语义，即生产者投递到服务端")]),s._v(" "),a("ul",[a("li",[s._v("如何保证消息最多投递一次")]),s._v(" "),a("li",[s._v("如何保证消息至少投递一次")]),s._v(" "),a("li",[s._v("如何保证消息恰好投递一次")])]),s._v(" "),a("p",[s._v("消费语义，即消费者消费服务端")]),s._v(" "),a("ul",[a("li",[s._v("如何保证消息最多消费一次")]),s._v(" "),a("li",[s._v("如何保证消息至少消费一次")]),s._v(" "),a("li",[s._v("如何保证消息恰好消费一次")])]),s._v(" "),a("p",[s._v("以下对各种语义，用kafka进行讲解：")]),s._v(" "),a("h2",{attrs:{id:"_1-生产者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-生产者"}},[s._v("#")]),s._v(" 1. 生产者")]),s._v(" "),a("h3",{attrs:{id:"如何保证消息最多投递一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息最多投递一次"}},[s._v("#")]),s._v(" 如何保证消息最多投递一次")]),s._v(" "),a("p",[s._v("消息最多投递一次，即消息要么不投递，要么只投递成功一次")]),s._v(" "),a("p",[s._v("简单，就是我已经投出去了，收没收到不管了，会存在消息丢失。\n我们在初始化"),a("code",[s._v("Producer")]),s._v("时可以通过配置"),a("code",[s._v("request.required.acks")]),s._v("不同的值,来实现不同的发送模式。\n这里将"),a("code",[s._v("request.required.acks")]),s._v("设为0，意思就是"),a("code",[s._v("Producer")]),s._v("不等待Leader确认，只管发出即可；最可能丢失消息。如果丢了消息，就是投递0次。如果没丢，就是投递1次。符合最多投递一次的含义。")]),s._v(" "),a("h3",{attrs:{id:"如何保证消息至少投递一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息至少投递一次"}},[s._v("#")]),s._v(" 如何保证消息至少投递一次")]),s._v(" "),a("p",[s._v("消息要么重复发送，要么只发送成功一次")]),s._v(" "),a("p",[s._v("这里将"),a("code",[s._v("request.required.acks")]),s._v("设为-1。"),a("code",[s._v("Producer")]),s._v("往"),a("code",[s._v("kafka")]),s._v("的"),a("code",[s._v("Leader（主）")]),s._v("节点发送消息后，会等"),a("code",[s._v("follower(从)")]),s._v("节点同步完数据以后，再给"),a("code",[s._v("Producer")]),s._v("返回ACK确认消息。\n但是这里是有几率出现重复消费的问题的。\n例如，"),a("code",[s._v("kafka")]),s._v("保存消息后，发送ACK前宕机，"),a("code",[s._v("Producer")]),s._v("认为消息未发送成功并重试，造成数据重复！\n那么，在这种情况下，就会出现大于1次的投递情况，符合至少投递一次的含义。")]),s._v(" "),a("h3",{attrs:{id:"如何保证消息恰好投递一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息恰好投递一次"}},[s._v("#")]),s._v(" 如何保证消息恰好投递一次")]),s._v(" "),a("p",[s._v("消息发送确保只成功发送一次")]),s._v(" "),a("p",[a("code",[s._v("kafka")]),s._v("在0.11.0.0版本之后支持恰好投递一次的语义。\n我们将"),a("code",[s._v("enable.idempotence")]),s._v("设置为ture,此时就会默认把"),a("code",[s._v("request.required.acks")]),s._v("设为-1，可以达到恰好投递一次的语义。\n"),a("em",[s._v("如何做到的？")]),s._v("\n为了实现"),a("code",[s._v("Producer")]),s._v("的幂等语义，Kafka引入了Producer ID（即PID）和Sequence Number。\n"),a("code",[s._v("kafka")]),s._v("为每个"),a("code",[s._v("Producer")]),s._v("分配一个pid，作为该"),a("code",[s._v("Producer")]),s._v("的唯一标识。\n"),a("code",[s._v("Producer")]),s._v("会为每一个<topic,partition>维护一个单调递增的seq。\n类似的，"),a("code",[s._v("Message Queue")]),s._v("也会为每个<pid,topic,partition>记录下最新的seq。\n当req_seq == message_seq+1时，"),a("code",[s._v("Message Queue")]),s._v("才会接受该消息。因为：")]),s._v(" "),a("ul",[a("li",[s._v("(1)消息的seq比"),a("code",[s._v("Message Queue")]),s._v("的seq大一以上，说明中间有数据还没写入，即乱序了。")]),s._v(" "),a("li",[s._v("(2)消息的seq比"),a("code",[s._v("Message Queue")]),s._v("的seq小，那么说明该消息已被保存。")])]),s._v(" "),a("h2",{attrs:{id:"_2-消费者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-消费者"}},[s._v("#")]),s._v(" 2.消费者")]),s._v(" "),a("h3",{attrs:{id:"如果保证消息最多消费一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果保证消息最多消费一次"}},[s._v("#")]),s._v(" 如果保证消息最多消费一次")]),s._v(" "),a("p",[s._v("消费者要么消费，要么只消费一次")]),s._v(" "),a("p",[s._v("其实这里根消费者的位移提交机制有关。")]),s._v(" "),a("p",[s._v("按照下面的处理方式")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("consumer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("poll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nconsumer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("commit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("processMsg")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("msg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("消费者如果在处理消息前宕机，那么下次消费时将不会再处理消息，消息丢失。即最多就消费了一次。")]),s._v(" "),a("h3",{attrs:{id:"如果保证消息至少消费一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果保证消息至少消费一次"}},[s._v("#")]),s._v(" 如果保证消息至少消费一次")]),s._v(" "),a("p",[s._v("消费者要么消费一次，要么多次消费")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("consumer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("poll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("processMsg")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("msg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nconsumer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("commit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("消费者如果在提交位移前宕机，那么下次消费时将再次处理，消息重复消费。即消息进行了多次消费。")]),s._v(" "),a("h3",{attrs:{id:"如果保证消息只消费一次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果保证消息只消费一次"}},[s._v("#")]),s._v(" 如果保证消息只消费一次")]),s._v(" "),a("p",[s._v("https://juejin.cn/post/7002169135908012062#heading-8")]),s._v(" "),a("p",[s._v("思路：至少一次 + 幂等性(为每条消息分配唯一id，并在第三方缓存中进行幂等性去重)")]),s._v(" "),a("p",[s._v("https://www.yuque.com/u1047901/hs89ud/aagb2utmhitxtccv")])])}),[],!1,null,null,null);a.default=n.exports}}]);