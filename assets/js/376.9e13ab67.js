(window.webpackJsonp=window.webpackJsonp||[]).push([[376],{700:function(t,a,i){"use strict";i.r(a);var e=i(4),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"一些命令需要注意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些命令需要注意"}},[t._v("#")]),t._v(" 一些命令需要注意")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("git add -u 仅仅添加已经被git追踪且跟新的文件到咱存区，不会添加没有被跟踪的文件")])]),t._v(" "),a("li",[a("p",[t._v("git reset --hard commitHash 回退到某个commit，并放弃其后的commit")])])]),t._v(" "),a("p",[t._v("git reset --hard 就是放弃当前的所有更改，回到最近的一个提交状态")]),t._v(" "),a("p",[t._v("git reset --hard HEAD~1")]),t._v(" "),a("p",[t._v("问：如果git reset --hard 到错误的版本还有机会复原吗？")]),t._v(" "),a("p",[t._v("可以的，只要我们拿到对应的commitHash就可以")]),t._v(" "),a("ul",[a("li",[t._v("方案一：")])]),t._v(" "),a("p",[t._v("使用git reflog ，可以查看历史HEAD的指向commit，我们拿到对应的commitHash后，使用git reset --hard commitHash就可以了")]),t._v(" "),a("ul",[a("li",[t._v("方案二;")])]),t._v(" "),a("p",[t._v("去.git/objects中查找对应的节点，但是这种形式可能效率较低，建议使用方案一")]),t._v(" "),a("p",[t._v("恢复本质：拿到想要恢复版本的commitHash")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("文件名字修改规范操作")])]),t._v(" "),a("ul",[a("li",[t._v("之前的流程")])]),t._v(" "),a("p",[t._v("将本地目录 mv fileName1 fileName2")]),t._v(" "),a("p",[t._v("在暂存区 git rm fileName1")]),t._v(" "),a("p",[t._v("将新文件加到暂存区 git add fileName2")]),t._v(" "),a("ul",[a("li",[t._v("规范的流程")])]),t._v(" "),a("p",[t._v("git mv fileName1 fileName2\n可以不用进行add等")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("p",[t._v("版本日志\ngit log\ngit log --oneline  以一行的形式显示日志\ngit log -n4    查看最新的n条日制\ngit log --graph  以地图的形式查看\ngit log --all   查看全部日志")])]),t._v(" "),a("li",[a("p",[t._v("查看git 对象信息\ngit cat-file -t hash   查看hash 的类型\ngit cat-file -p hash  查看hash的具体信息")])]),t._v(" "),a("li",[a("p",[t._v(".git中四个重要的目录\nconfig 本地git配置信息\nrefs git中不同分之的信息\nHEAD 当前使用的分支\nobjects 存放了tree等信息")])]),t._v(" "),a("li",[a("p",[t._v("怎么删除不需要的分支")])])]),t._v(" "),a("p",[t._v("检测删除（可能检测是否需要合并）git branch -d 分支名")]),t._v(" "),a("p",[t._v("强制删除 git branch -D 分支名")]),t._v(" "),a("ol",{attrs:{start:"8"}},[a("li",[t._v("修改已提交的commit的message")])]),t._v(" "),a("p",[t._v("git commit -amend 对最近一次提交作出变更")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408161121477.png",alt:"image-20230408161121477"}})]),t._v(" "),a("ol",{attrs:{start:"9"}},[a("li",[t._v("对旧的commit进行变更")])]),t._v(" "),a("p",[t._v("git rebase -i commithash的父亲")]),t._v(" "),a("p",[t._v("rebase是基于的意思，我们要修改commit1，那么我们要在commit1的父节点来进行修改commit2")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408162942375.png",alt:"image-20230408162942375"}})]),t._v(" "),a("p",[t._v("需要进行实战commit message进行修改")]),t._v(" "),a("p",[t._v("首先最基本的就是应该知道git rebase到底有什么用")]),t._v(" "),a("p",[t._v("①目前看看项目中的git日志")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409012918100.png",alt:"image-20230409012918100"}})]),t._v(" "),a("p",[t._v("②我们现在要把00eebc1 的commit信息改为second")]),t._v(" "),a("p",[t._v("git rebase -i be58967 (注意，这里我们需要rebase想要更改的commit的父commit)")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013450069.png",alt:"image-20230409013450069"}})]),t._v(" "),a("p",[t._v("从图上看出，真实有效的为第一行，其他的都是help注释，这里我们将pick改为reword来更改message")]),t._v(" "),a("p",[t._v("保存退出后，会自动跳转到下面的界面，我们将对应的数据更改为second就可以了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013533013.png",alt:"image-20230409013533013"}})]),t._v(" "),a("p",[t._v("可以看见更改成功了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409013612048.png",alt:"image-20230409013612048"}})]),t._v(" "),a("p",[t._v("注意，以上的变更一般在自己开发的分支上进行变更，在合作开发时，一般不要随意变更别人message")]),t._v(" "),a("ol",{attrs:{start:"10"}},[a("li",[t._v("怎么把几个连续的commit变为一个commit")])]),t._v(" "),a("p",[t._v("①选择需要合并commit的父commit作为rebase。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409014942471.png",alt:"image-20230409014942471"}})]),t._v(" "),a("p",[t._v("如图所示，我想要合并2,3,4 那么我应该将first作为rebase")]),t._v(" "),a("p",[t._v("Git rebase -i be58967")]),t._v(" "),a("p",[t._v("②将要进行合并的分支选做squash命令")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015722356.png",alt:"image-20230409015722356"}})]),t._v(" "),a("p",[t._v("③添加合并后的commit message")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015840569.png",alt:"image-20230409015840569"}})]),t._v(" "),a("p",[t._v("合并成功·")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409015951181.png",alt:"image-20230409015951181"}})]),t._v(" "),a("p",[t._v("从上面可以看出来，似乎rebase操作都会涉及到"),a("strong",[t._v("分离头指针")])]),t._v(" "),a("p",[t._v("看到上面的，合并后的commit相当于生成了一个新的commitHash，而最新的节点commit因为其父节点变化了，所以自己也产生了一个新的commithash,所以才会出现updated refs/heads/main，就是因为分支main指向的节点已经变化了。")]),t._v(" "),a("ol",{attrs:{start:"11"}},[a("li",[t._v("怎么把几个间隔的commit变成一个comomit")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023057138.png",alt:"image-20230409023057138"}})]),t._v(" "),a("p",[t._v("如图所示，我想将first合并到fifth分支，该怎么做了。我们之前说了rebase要有一个根基，但是现在first父节点我们是没有的该怎么办？")]),t._v(" "),a("ul",[a("li",[t._v("复制first的hash，然后在rebase -i中进行添加")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023422335.png",alt:"image-20230409023422335"}})]),t._v(" "),a("p",[t._v("如图所示，我们手动添加了第一行commit。")]),t._v(" "),a("p",[t._v("现在我们要将first合并到fifth应该怎么做了？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023614781.png",alt:"image-20230409023614781"}})]),t._v(" "),a("p",[t._v("若果有冲突解决冲突，然后填写新commit的message")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023837990.png",alt:"image-20230409023837990"}})]),t._v(" "),a("p",[t._v("保存退出即可:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230409023908863.png",alt:"image-20230409023908863"}})]),t._v(" "),a("p",[t._v("当您使用 git rebase 命令合并多个 commit 时，实际上是修改了本地的 Git 历史记录。如果此时直接使用 git push 命令将修改推送到远程仓库，那么 Git 会拒绝此操作，提示 “non-fast-forward” 错误。")]),t._v(" "),a("p",[t._v("这是因为 Git 的默认行为是只允许进行 fast-forward 合并，也就是只允许在原有基础上新增提交，而不允许强制覆盖历史记录。如果要将修改推送到远程仓库，需要使用 git push --force 或 git push -f 命令。")]),t._v(" "),a("p",[t._v("然而，强制推送可能会导致潜在的问题，如意外覆盖他人提交、丢失历史记录等，所以在进行强制推送前，请确保您已经充分理解其风险，并谨慎操作。")]),t._v(" "),a("p",[t._v("另一种更安全的方法是使用 git push --force-with-lease 命令。该命令会先检查远程仓库的状态，确保没有其他人在您之前推送过修改，然后再进行强制推送。这可以避免意外覆盖他人提交的风险。")]),t._v(" "),a("ol",{attrs:{start:"12"}},[a("li",[t._v("diff操作")])]),t._v(" "),a("p",[t._v("怎么对比暂存区与已经提交的版本之间的差异")]),t._v(" "),a("p",[t._v("git diff --cached")]),t._v(" "),a("p",[t._v("怎么对比工作区与暂存区之间的差异")]),t._v(" "),a("p",[t._v("git diff")]),t._v(" "),a("p",[t._v("只针对某一个文件")]),t._v(" "),a("p",[t._v("git diff -- fileName1 fileName2")]),t._v(" "),a("p",[t._v("撤销暂存区")]),t._v(" "),a("p",[t._v("git reset Head -- filename1 filename2")]),t._v(" "),a("p",[t._v("Git reset HEAD 撤销全部")]),t._v(" "),a("p",[t._v("撤销工作区")]),t._v(" "),a("p",[t._v("git checkout -- filename1 filename2")]),t._v(" "),a("p",[t._v("删除最近的几次commit")]),t._v(" "),a("p",[t._v("git reset --hard hash")]),t._v(" "),a("p",[t._v("看几次commit之间的差异")]),t._v(" "),a("p",[t._v("git diff commt1 commit2 -- file")]),t._v(" "),a("ol",{attrs:{start:"13"}},[a("li",[t._v("删除文件姿势")])]),t._v(" "),a("p",[t._v("git rm file")]),t._v(" "),a("p",[t._v("也会自动将工作区的进行文件删除")]),t._v(" "),a("p",[t._v("git stash pop /apply 区别")]),t._v(" "),a("ol",{attrs:{start:"14"}},[a("li",[t._v("指定不需要纳入git的文件")])]),t._v(" "),a("p",[t._v(".gitignore")]),t._v(" "),a("h2",{attrs:{id:"git中的对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git中的对象"}},[t._v("#")]),t._v(" git中的对象")]),t._v(" "),a("p",[t._v("git中的四个重要对象commit 、 tree、 blob、tag（tag可以去tag专题看介绍，下面只介绍其他三种）")]),t._v(" "),a("p",[t._v("文件管理")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408114209684.png",alt:"image-20230408114209684"}})]),t._v(" "),a("p",[t._v("在Git中，commit、tree和blob是三个核心的对象类型，它们有着紧密的关系。")]),t._v(" "),a("h3",{attrs:{id:"对象的介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的介绍"}},[t._v("#")]),t._v(" 对象的介绍")]),t._v(" "),a("p",[t._v("首先，blob（二进制大对象）是指文件的内容，它可以是任何类型的文件，包括源代码、图像、音频或视频等。每个blob在Git仓库中都有一个唯一的SHA-1哈希值来标识它。")]),t._v(" "),a("p",[t._v("其次，tree（树对象）是一种特殊的对象，它描述了一个目录的结构，包含一个或多个blob对象和其他tree对象，以及它们之间的关系。与blob一样，每个tree也有一个唯一的SHA-1哈希值。")]),t._v(" "),a("p",[t._v("最后，commit（提交对象）指向一个tree对象，并包含一些元数据，例如提交者、时间戳、提交消息等。当创建一个新的提交时，Git会创建一个新的commit对象并将其指向当前的tree对象。每个commit也有一个唯一的SHA-1哈希值。")]),t._v(" "),a("p",[t._v("因此，这三种对象类型的关系如下：一个commit对象指向一个tree对象，该tree对象描述了当前版本的目录结构，而该目录结构由一些blob对象组成，它们表示实际的文件内容。")]),t._v(" "),a("h3",{attrs:{id:"对象之间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象之间的关系"}},[t._v("#")]),t._v(" 对象之间的关系")]),t._v(" "),a("p",[t._v("一次commit对应着一个文件目录版本。一次commit会对应多个tree。一个tree相当于一个目录，tree下面也会对应多个tree或多个blob。一个blob相当于一个文件，在git中认为只要是文件内容相同，则认为是同一个blob")]),t._v(" "),a("p",[t._v("例如查看一个commit的详细信息：")]),t._v(" "),a("p",[t._v("git cat-file -p 4a4a8dea2a36bc3f476")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408120536680.png",alt:"image-20230408120536680"}})]),t._v(" "),a("p",[t._v("从里的tree我们都明白了，其实就是指向了一个文件。")]),t._v(" "),a("p",[t._v("但是这里的parent又是什么东西呢？")]),t._v(" "),a("p",[t._v("在 Git 中，每个提交记录都包含一个指向其父提交（或上一个提交）的指针。这些父提交可以是单个提交，也可以是多个提交，形成分支或合并历史记录。")]),t._v(" "),a("p",[t._v("在提交对象中，parent字段是一个指向一个或多个父提交的哈希值的列表。当创建一个新的提交时，Git 将会把当前的分支指向新的提交，同时将新的提交的 parent 字段设置为现有提交的哈希值。这样就形成了一系列有向无环图（DAG），用于表示代码库的历史版本。")]),t._v(" "),a("p",[a("strong",[t._v("tree字段则指向该提交的根目录的哈希值")]),t._v("，表示这个提交所包含的文件和目录结构。通过跟踪 tree 和 parent 哈希值，Git 可以追溯整个代码库的历史记录，并允许用户查看先前的版本，比较更改和合并不同的历史记录。")]),t._v(" "),a("h3",{attrs:{id:"git对象实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git对象实践"}},[t._v("#")]),t._v(" git对象实践")]),t._v(" "),a("p",[t._v("问题：新建一个git仓库，有且仅有1个commit，仅仅包含/doc/readme，请问有多少个tree，多少个blob")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408141742391.png",alt:"image-20230408141742391"}})]),t._v(" "),a("h3",{attrs:{id:"三大对象再理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三大对象再理解"}},[t._v("#")]),t._v(" 三大对象再理解")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412104615319.png",alt:"image-20230412104615319"}})]),t._v(" "),a("p",[t._v("这些对象都存在.git目录中的objects中")]),t._v(" "),a("p",[t._v("当我们进行clone或者push时，")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412105000394.png",alt:"image-20230412105000394"}})]),t._v(" "),a("p",[t._v("另外，如果更改一个文件的内容，只改变一点也会创建一个新的object，因为hash变了")]),t._v(" "),a("h4",{attrs:{id:"实际操作理解对象创建过程以及关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际操作理解对象创建过程以及关系"}},[t._v("#")]),t._v(" 实际操作理解对象创建过程以及关系")]),t._v(" "),a("p",[t._v("需要细细研究，有点东西")]),t._v(" "),a("p",[t._v("https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247541766&idx=1&sn=8091a5f18aa7ede19557e2142637cf9a&chksm=e9c2c3f1deb54ae713eb48eb3e65e4a498df0ca0aca542cc4a971f261a0efe4aa79fff9e3bf9&mpshare=1&scene=23&srcid=0411xXR0BBftW5H0X098wgcm&sharer_sharetime=1681227533623&sharer_shareid=4d2ece652c18043ba9427f6fbfc02bc2#rd")]),t._v(" "),a("p",[t._v("首先我在创建一个结构目录如下的文件：")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("./git\ndoc\n - readme.txt\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("p",[t._v("其中readme.txt的文件内容如下：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("hello world\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("现在我们将所有的文件进行提交，然后查看objects，目录下有哪些文件:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412162638999.png",alt:"image-20230412162638999"}})]),t._v(" "),a("p",[t._v("如图新增了4个文件，根据之前的学习，我们猜测目录结构如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412162821413.png",alt:"image-20230412162821413"}})]),t._v(" "),a("p",[t._v("使用git cat-file -p 命令查看hash的类型进行验证")]),t._v(" "),a("div",{staticClass:"language-txt line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[t._v("git cat-file -p 2e9e6cd9fef232a6f0ecab0523718725b5bfdb24\n040000 tree e7a75e980c7adc0d5ab1c49ecff082b518bb6cf8    doc\n\ngit cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad\nhello world\n\ngit cat-file -p e7a75e980c7adc0d5ab1c49ecff082b518bb6cf8 \n100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    readme.txt\n\ngit cat-file -p f9843075fd6e4618f4c4081bce7cc9ce99986788\ntree 2e9e6cd9fef232a6f0ecab0523718725b5bfdb24\nauthor zj<XXX@qq.com> 1681285686 +0800\ncommitter zj<XXX@qq.com> 1681285686 +0800\n\ncommmit message\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])]),a("p",[t._v("(省略了-t 查看hash类型的操作，上面查询的是hash里的具体内容)")]),t._v(" "),a("p",[t._v("从上面这个我们就可以推测出下面的图示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163359806.png",alt:"image-20230412163359806"}})]),t._v(" "),a("p",[t._v("以上就是我们第一次提交的内容，我们使用git log看看：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163441536.png",alt:"image-20230412163441536"}})]),t._v(" "),a("p",[t._v("如图，可以看出来日志内容中显示了commit对象的hash f9。")]),t._v(" "),a("p",[t._v("那么我们对readme文件进行修改，在最后一排添加一排111，然后进行提交到暂存区：")]),t._v(" "),a("p",[t._v("其实我们将文件添加到暂存区时，就已经会产生一个blob文件了，该文件就是新增了111的文件版本：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412163942066.png",alt:"image-20230412163942066"}})]),t._v(" "),a("p",[t._v("那么我们将本次进行提交呢？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164308127.png",alt:"image-20230412164308127"}})]),t._v(" "),a("p",[t._v("其实就会发现会新增3个object，我们分别来看看每个object的内容")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164802081.png",alt:"image-20230412164802081"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164538149.png",alt:"image-20230412164538149"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412164614495.png",alt:"image-20230412164614495"}})]),t._v(" "),a("p",[t._v("根据上面我们又可以形成新的图示")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165027767.png",alt:"image-20230412165027767"}})]),t._v(" "),a("p",[t._v("其实这么看差不多就理解了，当我们进行一次新的提交，因为应该了对应的文件readme，其会生成一个新的objectHash，而此时因为其hash变了，其当前目录为了记录历史记录，不得不生成一个新的tree来指向最新的文件，循环往复，直到最新的commit指向新建的tree。")]),t._v(" "),a("p",[t._v("可以得出一个结论，只要一个文件修改了，commit后，一定会产生新的commit和tree。而那些不变的文件，tree指向他们的原hash就可以。")]),t._v(" "),a("p",[t._v("例如我现在在doc下新建一个目录java，并在java下创建一个Main.java文件，commit后预期的结果应该如下所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165634272.png",alt:"image-20230412165634272"}})]),t._v(" "),a("p",[t._v("预期会增加5个节点。我们进行实际操作看看是不是呢？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412165957583.png",alt:"image-20230412165957583"}})]),t._v(" "),a("p",[t._v("发现实际只增加了4个节点，很意外，我们看看每个hash的内容是什么")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170513796.png",alt:"image-20230412170513796"}})]),t._v(" "),a("p",[t._v("发现缺少了提交的commit，怎么回事？我们看看git log")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170748930.png",alt:"image-20230412170748930"}})]),t._v(" "),a("p",[t._v("其实看到了我们最新的提交a4开头。")]),t._v(" "),a("p",[t._v("这下我们就知道了，在/a4下面其实有两个文件，我们没有注意")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412170859918.png",alt:"image-20230412170859918"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171037992.png",alt:"image-20230412171037992"}})]),t._v(" "),a("p",[t._v("这下就符合预期了，生成了5个节点是正确的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171232647.png",alt:"image-20230412171232647"}})]),t._v(" "),a("h2",{attrs:{id:"git-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-gc"}},[t._v("#")]),t._v(" git gc")]),t._v(" "),a("p",[t._v("我们试试一个新的命令：git gc"),a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171557206.png",alt:"image-20230412171557206"}})]),t._v(" "),a("p",[t._v("此时我们在objects目录下看看，我们的hash不在了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412171936478.png",alt:"image-20230412171936478"}})]),t._v(" "),a("p",[t._v("其实我们的东西跑到pack里面去了")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412172035120.png",alt:"image-20230412172035120"}})]),t._v(" "),a("p",[t._v("怎么查看pack的内容：")]),t._v(" "),a("p",[t._v("执行 git verify-pack -v 看下 idx 文件的内容：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412172327528.png",alt:"image-20230412172327528"}})]),t._v(" "),a("p",[t._v("可以看到，我们所有的hash都压缩到这里了")]),t._v(" "),a("p",[t._v("//TODO : 后面跟着一长串的东西是什么 chain")]),t._v(" "),a("p",[t._v("我们使用git gc时候，是不是和我们进行push时很相似，这一看就明白了：每次push时，其实会将我们本地在object中hash进行gc打包到pack中，下次我们clone下来时，服务端也会进行gc后再传输")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230412173450453.png",alt:"image-20230412173450453"}})]),t._v(" "),a("p",[t._v("也就是说gc会对objects中的对象进行压缩。")]),t._v(" "),a("p",[t._v("在远程仓库中一般不会存储.git目录：")]),t._v(" "),a("p",[a("code",[t._v(".git")]),t._v(" 目录是 Git 用来存储仓库的版本历史和元数据的目录，包含了 Git 所需的所有信息。该目录通常位于仓库的根目录中，但它被设计为隐藏目录，因此默认情况下不会在文件浏览器或终端窗口中显示。")]),t._v(" "),a("p",[t._v("虽然你可以在本地访问 "),a("code",[t._v(".git")]),t._v(" 目录，但 GitHub 不会公开任何仓库的 "),a("code",[t._v(".git")]),t._v(" 目录或其内容。GitHub 提供了 Git 命令行工具、API 和 Web 界面等多种途径来管理仓库和进行版本控制。")]),t._v(" "),a("p",[a("code",[t._v("git gc")]),t._v(" 主要有以下作用：")]),t._v(" "),a("ol",[a("li",[t._v("清理无用的对象。Git 会自动引用（reference）一些对象，例如最新的提交对象和分支头等，但是有些对象可能已经不再被引用，也就是所谓的无用对象。"),a("code",[t._v("git gc")]),t._v(" 可以帮助我们找到并删除这些无用的对象，从而释放磁盘空间。")]),t._v(" "),a("li",[t._v("压缩对象。Git 中的对象通常以松散格式存储，这样可以方便地添加和修改，但同时会占用更多的磁盘空间和读写时间。"),a("code",[t._v("git gc")]),t._v(" 可以把松散格式对象压缩成紧凑格式，从而进一步减少磁盘占用，并提高读写性能。")]),t._v(" "),a("li",[t._v("优化仓库。"),a("code",[t._v("git gc")]),t._v(" 还会执行其他一些优化操作，例如压缩历史记录、删除冗余数据等，从而提高 Git 仓库的整体性能。")])]),t._v(" "),a("p",[t._v("需要注意的是，"),a("code",[t._v("git gc")]),t._v(" 命令可能需要一些时间来完成，特别是对于大型仓库来说。此外，建议不要频繁地手动执行 "),a("code",[t._v("git gc")]),t._v("，因为这可能会影响你的工作流程和 Git 的性能。通常情况下，我们可以让 Git 在满足一定条件时自动运行 "),a("code",[t._v("git gc")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"分离头指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分离头指针"}},[t._v("#")]),t._v(" 分离头指针")]),t._v(" "),a("p",[t._v("什么是git中的分离头指针：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230408154444722.png",alt:"image-20230408154444722"}})]),t._v(" "),a("p",[t._v("HEAD detached at hash")]),t._v(" "),a("p",[t._v("Git的分离头指针（Detached HEAD）是指当前工作树（Working Tree）处于HEAD指针指向的提交（Commit）之外的一种状态。在分离头指针状态下，Git不再跟踪分支（Branch）而是直接跟踪提交。")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("git checkout <commit>")]),t._v("命令切换到一个特定的提交时，就会进入分离头指针状态。这种情况通常发生在以下几种情况：")]),t._v(" "),a("ol",[a("li",[t._v("执行"),a("code",[t._v("git checkout <tag>")]),t._v("或"),a("code",[t._v("git checkout <commit hash>")]),t._v("等命令，但未创建新的分支来跟踪这个提交；")]),t._v(" "),a("li",[t._v("在某个分支上进行修改，但在提交这些修改前执行了"),a("code",[t._v("git checkout <commit>")]),t._v("命令。")])]),t._v(" "),a("p",[t._v("如果在分离头指针状态下进行修改并提交，那么这些提交将会成为孤立的提交（Orphan Commits），也就是没有任何分支指向的提交。")]),t._v(" "),a("h3",{attrs:{id:"怎么产生"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么产生"}},[t._v("#")]),t._v(" 怎么产生？")]),t._v(" "),a("p",[t._v("git checkout commitHash")]),t._v(" "),a("p",[t._v("这时就产生了分离头指针，改指针并没有与任何的分支进行关联，当然我们可以在这里进行提交，但是因为没有任何分支进行关联，当我们突然切换到另一个分支过后，分离头指针上提交的commit就会丢失")]),t._v(" "),a("p",[t._v("那么分离头指针就完全没有用了吗？")]),t._v(" "),a("p",[t._v("分离头指针的优点是：")]),t._v(" "),a("ol",[a("li",[t._v("可以方便地查看、修改、测试历史提交，无需创建新的分支或拉取代码；")]),t._v(" "),a("li",[t._v("可以快速切换到不同的提交和版本，方便进行版本回退；")]),t._v(" "),a("li",[t._v("可以在不影响当前分支的情况下修改和提交代码。")])]),t._v(" "),a("p",[t._v("分离头指针的缺点是：")]),t._v(" "),a("ol",[a("li",[t._v("在分离头指针状态下进行修改并提交，这些提交将成为孤立的提交，没有任何分支指向它们，可能会导致难以维护的仓库历史；")]),t._v(" "),a("li",[t._v("分离头指针状态下，无法使用"),a("code",[t._v("git pull")]),t._v("等命令自动获取最新的远程更新；")]),t._v(" "),a("li",[t._v("当需要继续开发时，需要创建新的分支来跟踪当前的工作，否则会丢失之前的提交记录。")])]),t._v(" "),a("p",[t._v("因此，在实际应用中，建议尽量避免使用分离头指针状态，只有在特殊情况下才使用。")]),t._v(" "),a("h2",{attrs:{id:"head与branch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#head与branch"}},[t._v("#")]),t._v(" HEAD与Branch")]),t._v(" "),a("p",[t._v("正常情况下HEAD中保存的数据是一个地址的引用。")]),t._v(" "),a("p",[t._v("从目录的ref来看，其实真实指向的是一个commit，所以最总一个head不是指向多个commit，而是指向一个具体的commit。而这个commit有父亲节点可以访问，就间接的包含了多个commit")]),t._v(" "),a("p",[t._v("既然HEAD和branch本质上都指向了commit，其实我们的所有操作基本上都是基于commit进行操作，比如对比两侧commit的差异：")]),t._v(" "),a("p",[t._v("git diff commit1 commit2")]),t._v(" "),a("p",[t._v("git diff HEAD HEAD^")]),t._v(" "),a("p",[t._v("Git diff HEAD HEAD^^")]),t._v(" "),a("p",[t._v("git diff HEAD HEAD~2")]),t._v(" "),a("h2",{attrs:{id:"git的作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git的作用域"}},[t._v("#")]),t._v(" git的作用域")]),t._v(" "),a("p",[t._v("git config 可以用来配置 Git 客户端的行为和属性。其作用域可以分为三种：")]),t._v(" "),a("ol",[a("li",[t._v("local：只对某个特定的仓库有效，设置在当前仓库的 .git/config 文件中。")]),t._v(" "),a("li",[t._v("global：对当前用户的所有仓库都有效，存储在当前用户根目录下的 .gitconfig 文件中。")]),t._v(" "),a("li",[t._v("system：对系统上所有登录用户的所有仓库都有效，通常存储在 /etc/gitconfig 文件中。")])]),t._v(" "),a("p",[t._v("当同一个属性在多个配置文件中都有定义时，Git 会按照 local、global、system 的优先级依次查找并采用最后一个定义的值。")]),t._v(" "),a("p",[t._v("其中优先级别 local > global > system")]),t._v(" "),a("h2",{attrs:{id:"git别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git别名"}},[t._v("#")]),t._v(" Git别名")]),t._v(" "),a("p",[t._v("推荐日志别名：")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("alias"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        lg "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" log "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--color")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--graph")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--pretty")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("format:"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset'")]),t._v(" --abbrev-commit\n        dog "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" log "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--all")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--decorate")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--oneline")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--graph")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("ol",[a("li",[t._v("设置"),a("code",[t._v("git")]),t._v("命令别名")])]),t._v(" "),a("p",[a("code",[t._v("git config <作用域> alias.<别名> '<命令>'")])]),t._v(" "),a("p",[a("code",[t._v("git config --global alias.dog 'log --all --decorate --oneline --graph'")])]),t._v(" "),a("p",[t._v("对应的信息会写入到对应作用域的配置文件里面")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("设置外部命令别名")])]),t._v(" "),a("p",[t._v("像"),a("code",[t._v("gitk")]),t._v("这样的外部命令，是没有"),a("code",[t._v("git")]),t._v("前缀的。设置别名的方法与设置"),a("code",[t._v("git")]),t._v("提供的命令有所不同，要按照如下格式设置：")]),t._v(" "),a("p",[a("code",[t._v("git config <作用域> alias.<别名> '<!外部命令>'")])]),t._v(" "),a("ul",[a("li",[t._v("感叹号表示这是一个外部命令；")]),t._v(" "),a("li",[t._v("注意要加上单引号，不用加"),a("code",[t._v("git")]),t._v("前缀；")])]),t._v(" "),a("p",[t._v("比如在系统用户作用域下，将"),a("code",[t._v("git ui")]),t._v("设置为"),a("code",[t._v("gitk")]),t._v("的别名：")]),t._v(" "),a("div",{staticClass:"language-csharp line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-csharp"}},[a("code",[t._v(" git config "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("global")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alias")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ui '"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("gitk'\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("设置完成后，该配置会被写入系统用户的配置文件"),a("code",[t._v("gitconfig")]),t._v("中")]),t._v(" "),a("p",[t._v("设置了别名后，原来的命令依然有效")]),t._v(" "),a("h2",{attrs:{id:"git-revert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-revert"}},[t._v("#")]),t._v(" git revert")]),t._v(" "),a("p",[t._v("其实revert 和reset的功能类似，都是撤销某次的commit。")]),t._v(" "),a("p",[t._v("但是两者有本质上的区别。")]),t._v(" "),a("p",[t._v("git reset是直接从分支上回退到对应的commit节点，如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230419141224956.png",alt:"image-20230419141224956"}})]),t._v(" "),a("p",[t._v("如图所示，当前HEAD指向3，如果我使用reset命令，会将HEAD指向2,commit3会断掉与2的关系。如果我们使用的是revert的话，其实其作用就是创建一个新的提交，新的提交中就做了相应的修改操作对应撤销操作，如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230419141745732.png",alt:"image-20230419141745732"}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230419142340308.png",alt:"image-20230419142340308"}})]),t._v(" "),a("p",[t._v("如何使用？")]),t._v(" "),a("p",[t._v("用法跟git reset一致")]),t._v(" "),a("h3",{attrs:{id:"两者区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两者区别"}},[t._v("#")]),t._v(" 两者区别")]),t._v(" "),a("p",[t._v("撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，"),a("code",[t._v("git reset")]),t._v("被设计为重设本地更改")]),t._v(" "),a("p",[t._v("因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，而撤销保留了原来的更改，用一个新的提交来实现撤销")]),t._v(" "),a("p",[t._v("两者主要区别如下：")]),t._v(" "),a("ul",[a("li",[t._v("git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit")]),t._v(" "),a("li",[t._v("git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容")]),t._v(" "),a("li",[t._v("在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别")])]),t._v(" "),a("blockquote",[a("p",[t._v("git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并")]),t._v(" "),a("p",[t._v("但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入")])]),t._v(" "),a("ul",[a("li",[t._v("如果回退分支的代码以后还需要的情况则使用"),a("code",[t._v("git revert")]),t._v("， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用"),a("code",[t._v("git reset")])])]),t._v(" "),a("h2",{attrs:{id:"git-rebase-与git-mergae有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-rebase-与git-mergae有什么区别"}},[t._v("#")]),t._v(" git rebase 与git mergae有什么区别")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://vue3js.cn/interview/git/git%20rebase_%20git%20merge.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://vue3js.cn/interview/git/git%20rebase_%20git%20merge.html"),a("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=s.exports}}]);