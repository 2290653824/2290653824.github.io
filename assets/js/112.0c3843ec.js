(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{436:function(s,e,a){"use strict";a.r(e);var t=a(4),n=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"了解一些命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#了解一些命令"}},[s._v("#")]),s._v(" 了解一些命令")]),s._v(" "),e("p",[s._v("INFO memory 查看当前的redis服务的内存占用情况")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518145917160.png",alt:"image-20230518145917160"}})]),s._v(" "),e("ul",[e("li",[e("code",[s._v("used_memory")]),s._v("：表示Redis服务器当前使用的内存总量（以字节为单位）。")]),s._v(" "),e("li",[e("code",[s._v("used_memory_human")]),s._v("：与used_memory相同的信息，但以人类可读的格式显示，例如使用MB或GB表示。")]),s._v(" "),e("li",[e("code",[s._v("used_memory_rss")]),s._v("：表示Redis进程在操作系统中的常驻集大小（Resident Set Size），表示Redis使用的物理内存总量。")]),s._v(" "),e("li",[e("code",[s._v("used_memory_peak")]),s._v("：表示Redis服务器历史上分配的最大内存峰值（以字节为单位）。")]),s._v(" "),e("li",[e("code",[s._v("used_memory_peak_human")]),s._v("：与used_memory_peak相同的信息，但以人类可读的格式显示。")]),s._v(" "),e("li",[e("code",[s._v("used_memory_lua")]),s._v("：表示Lua引擎使用的内存量（以字节为单位）。")]),s._v(" "),e("li",[e("code",[s._v("mem_fragmentation_ratio")]),s._v("：表示Redis内存碎片的比率，即内存分配和释放的比率。")]),s._v(" "),e("li",[e("code",[s._v("total_system_memory")]),s._v("：表示Redis运行所在系统的总内存大小（以字节为单位）。")]),s._v(" "),e("li",[e("code",[s._v("maxmemory")]),s._v("：表示Redis服务器配置的最大可用内存大小。")]),s._v(" "),e("li",[e("code",[s._v("maxmemory_human")]),s._v("：与maxmemory相同的信息，但以人类可读的格式显示。")]),s._v(" "),e("li",[e("code",[s._v("maxmemory_policy")]),s._v("：表示Redis服务器配置的淘汰策略。")]),s._v(" "),e("li",[e("code",[s._v("evicted_keys")]),s._v("：表示自Redis服务器启动以来因为内存不足而被驱逐的键的数量。")])]),s._v(" "),e("h2",{attrs:{id:"淘汰策略前提"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#淘汰策略前提"}},[s._v("#")]),s._v(" 淘汰策略前提")]),s._v(" "),e("p",[s._v("我们看到我们启动后maxmemory显示为0，是什么意思呢？")]),s._v(" "),e("p",[s._v("如果在Redis中使用 "),e("code",[s._v("INFO memory")]),s._v(" 命令后，"),e("code",[s._v("maxmemory")]),s._v(" 字段的值显示为 0，表示你的Redis服务器当前未配置最大可用内存限制。")]),s._v(" "),e("p",[s._v("当 "),e("code",[s._v("maxmemory")]),s._v(" 的值为 0 时，Redis将不会执行任何内存淘汰策略，而是允许数据无限增长，直到服务器的物理内存用尽。这意味着Redis将不会主动删除任何数据，而是将数据持续保存在内存中。")]),s._v(" "),e("p",[s._v("如果你希望配置最大可用内存限制，你可以通过修改Redis服务器的配置文件（通常是redis.conf）或者在启动Redis服务器时指定 "),e("code",[s._v("maxmemory")]),s._v(" 参数来设置最大内存值。例如，可以使用以下方式启动Redis并设置最大内存为 1GB：")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("redis-server "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("--maxmemory")]),s._v(" 1gb\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("请注意，为了使 "),e("code",[s._v("maxmemory")]),s._v(" 配置生效，你需要重新启动Redis服务器。")]),s._v(" "),e("p",[s._v("所以想要进一步实现淘汰策略，我们需要将maxmemory进行配置。")]),s._v(" "),e("blockquote",[e("p",[s._v("注意：要启动缓存策略，必须设置maxmemory，否则redis可以占用无限大内存，从而无法触发缓存策略。")])]),s._v(" "),e("p",[s._v("让我们在redis.conf中设置对应的maxmemory")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518151257401.png",alt:"image-20230518151257401"}})]),s._v(" "),e("p",[s._v("因为是我们在本地进行测试，我们设置为1300k吧。（其实是建议设置的更小的，因为当我们要测试LRU算法的时候，在海量数据中去看哪些数据丢失其实比较麻烦，这里我们可以把最大的maxmemory弄的更小，比如100B）")]),s._v(" "),e("p",[s._v("设置成功后重启redis即可。")]),s._v(" "),e("div",{staticClass:"language-SHELL line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("bin/redis-server redis.conf\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("成功后，我们再看看内存信息：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518151716799.png",alt:"image-20230518151716799"}})]),s._v(" "),e("p",[s._v("可以看到我们的最大内存已经设置成功了。而且在没有配置的情况下，默认的淘汰策略是noeviction")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("noeviction")]),s._v("（不淘汰策略）：当内存不足以容纳新写入的数据时，Redis会直接返回错误，并拒绝写入操作。")])]),s._v(" "),e("h2",{attrs:{id:"我们怎么知道一个key占用了多少的内存大小"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#我们怎么知道一个key占用了多少的内存大小"}},[s._v("#")]),s._v(" 我们怎么知道一个key占用了多少的内存大小？")]),s._v(" "),e("p",[s._v("可以使用命令查看key对应的键值对占用了多大的内存")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("MEMORY USAGE keyName\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"快速构建一个springboot程序使用组件快速让redis达到最大值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#快速构建一个springboot程序使用组件快速让redis达到最大值"}},[s._v("#")]),s._v(" 快速构建一个springboot程序使用组件快速让redis达到最大值")]),s._v(" "),e("p",[s._v("因为我们后面还需要测试其他的淘汰策略，所以我们需要统一一下key的规范，以便后续可以快速分析一个key是否被淘汰")]),s._v(" "),e("p",[s._v("写入时间-是否设置过期 : 上次使用时间    需要保证时间在毫秒级别")]),s._v(" "),e("p",[s._v("0518-15-24-234 : 0518-15-24-234")]),s._v(" "),e("p",[s._v("参考github")]),s._v(" "),e("p",[s._v("思路是将不同的key set到redis中，当对应的数据占用内存达到maxmemory时，")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518171858444.png",alt:"image-20230518171858444"}})]),s._v(" "),e("p",[s._v("此时，如果我们继续向redis set key，那么就是抛出异常：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518171938600.png",alt:"image-20230518171938600"}})]),s._v(" "),e("p",[s._v("使用 redisTemplate 也会抛出对相同的异常")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("Error "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" execution"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" nested exception is io.lettuce.core.RedisCommandExecutionException: OOM "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v(" not allowed when used memory "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'maxmemory'")]),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h2",{attrs:{id:"如果我们需要更改策略怎么办"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果我们需要更改策略怎么办"}},[s._v("#")]),s._v(" 如果我们需要更改策略怎么办")]),s._v(" "),e("p",[s._v("同样的需要子配置文件中更改对应的配置，然后重启redis服务。（再此之间，我们可以把我们上面测试写入redis的数据给清除掉aof、rdb。）")]),s._v(" "),e("ul",[e("li",[s._v("修改配置文件：")])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230518185409594.png",alt:"image-20230518185409594"}})]),s._v(" "),e("ul",[e("li",[s._v("删除落盘文件。")])]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("rm")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-rf")]),s._v(" dump.rdb \n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("再次启动后，再次看内存相关的信息：")]),s._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[s._v("127.0")]),s._v(".0.1:637"),e("span",{pre:!0,attrs:{class:"token operator"}},[e("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[s._v("9")]),s._v(">")]),s._v(" INFO memory\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# Memory")]),s._v("\nused_memory:1046912\nused_memory_human:1022.38K\nused_memory_rss:2453504\nused_memory_rss_human:2.34M\nused_memory_peak:1046912\nused_memory_peak_human:1022.38K\nused_memory_peak_perc:100.01%\nused_memory_overhead:1013630\nused_memory_startup:964000\nused_memory_dataset:33282\nused_memory_dataset_perc:40.14%\ntotal_system_memory:17179869184\ntotal_system_memory_human:16.00G\nused_memory_lua:37888\nused_memory_lua_human:37.00K\nmaxmemory:1500000\nmaxmemory_human:1.43M\nmaxmemory_policy:allkeys-lru\nmem_fragmentation_ratio:2.34\nmem_allocator:libc\nactive_defrag_running:0\nlazyfree_pending_objects:0\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br"),e("span",{staticClass:"line-number"},[s._v("23")]),e("br"),e("span",{staticClass:"line-number"},[s._v("24")]),e("br")])]),e("p",[s._v("怎么来验证这个算法呢？")]),s._v(" "),e("p",[s._v("我们可以将key设置为 allKeys-lru:num")]),s._v(" "),e("ul",[e("li",[s._v("从0开始一直向上加，当内存满时，可以看看0是否还存在，不存在，则表示成功")]),s._v(" "),e("li",[s._v("从0开始一直向上加，内存没满时，获取一次0，后待内存满时，0不会被删除，但是1会被删除。")])]),s._v(" "),e("p",[s._v("做的过程中遇到了什么问题：")]),s._v(" "),e("ul",[e("li",[s._v("数据量太大，导致插入redis的数据太多，不好分析数据")])]),s._v(" "),e("p",[s._v("尽量调小maxmemory，使之在向redis加入较少数据就可以出发淘汰策略。")]),s._v(" "),e("ul",[e("li",[s._v("redisTemplate怎么获取相关的内存信息？")])]),s._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Properties")]),s._v(" properties "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Properties")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("redisTemplate"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("execute")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("RedisCallback")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" connection "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("->")]),s._v(" connection"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("info")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" maxMemory "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" properties"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("getProperty")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"maxmemory"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Long")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("parseLong")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("properties"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("getProperty")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"maxmemory"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n            "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" usedMemory "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" properties"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("getProperty")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"used_memory"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("null")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Long")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("parseLong")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("properties"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("getProperty")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"used_memory"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("ul",[e("li",[s._v("我插入数据0-2000数据时，触发淘汰策略，此时我再插入100条数据，按理说0-100的数据将会被淘汰，但是实际上并没有，发现0-2000数据中随机有很多数据被淘汰，这么看来并不符合lru算法呀？")])]),s._v(" "),e("p",[s._v("配置中有一个配置maxmemory samples配置：")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230519080243960.png",alt:"image-20230519080243960"}})]),s._v(" "),e("p",[s._v("可以看出redis做出了这种优化。那么试想一下，如果我们把这个配置调成10000，那么我们前面的猜想0-100数据淘汰可以吗？经测试，是这样的，0-100的数据因lru算法被成功淘汰，因为根据配置随机选择了10000的数据进行了淘汰算法。")]),s._v(" "),e("ul",[e("li",[s._v("redis lru底层算法是怎么样的")])]),s._v(" "),e("p",[s._v("https://www.bilibili.com/video/BV1LA4y1R7bT/?spm_id_from=333.337.search-card.all.click")]),s._v(" "),e("ul",[e("li",[s._v("手写一个lru算法")])]),s._v(" "),e("p",[s._v("继续来测试一下volatile-lru算法：")]),s._v(" "),e("p",[e("code",[s._v("volatile-lru")]),s._v("：只对设定了过期时间的键进行淘汰，按照 LRU 算法进行淘汰。")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230519081330334.png",alt:"image-20230519081330334"}})]),s._v(" "),e("p",[s._v("测试思路：")]),s._v(" "),e("ul",[e("li",[s._v("所有的数据不包含ttl数据，那么怎么淘汰？0-2000全部是非ttl数据，测试怎么进行淘汰，是进行异常抛出？")])]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230519083254047.png",alt:"image-20230519083254047"}})]),s._v(" "),e("p",[s._v("可以看出，如果已经没有ttl的key，此时发生淘汰，是会直接抛出异常的。")]),s._v(" "),e("ul",[e("li",[s._v("设定0-2000的数据，其中10-100是ttl数据，且10-30是经常使用的数据，当我们触发了淘汰策略，应该淘汰的策略应该是31-100的数据")])]),s._v(" "),e("p",[s._v("其实经测试，确实是ttl的数据进行了淘汰，但是因为可能淘汰的数量过多，我们10-30经常使用的数据在31-100的数据淘汰完之后，也会对10-30的数据进行淘汰。")]),s._v(" "),e("p",[s._v("至此，上面说的lru的数据就已经讲解完了。")]),s._v(" "),e("p",[s._v("下面我们来看看lfu算法")]),s._v(" "),e("p",[s._v("https://www.bilibili.com/video/BV1HB4y1S7xj/?spm_id_from=333.337.search-card.all.click")]),s._v(" "),e("p",[s._v("LRU（Least Recently Used）和LFU（Least Frequently Used）都是用于缓存淘汰策略的算法，它们的主要区别在于如何定义和计算“最近使用”和“频率”。")]),s._v(" "),e("p",[s._v("LRU算法将最近使用的数据放到链表尾部，最久未使用的数据放到链表头部。当缓存满时，优先淘汰链表头部的数据。这样可以保证最近访问的数据能够被频繁地使用，缓存命中率高。")]),s._v(" "),e("p",[s._v("LFU算法则是根据数据被访问的频率来进行淘汰。每个数据块都有一个计数器来记录被使用的次数，当缓存满时，淘汰计数器值最小的数据块。这样可以保证经常访问的数据能够被保留在缓存中，缓存命中率也会更高。")]),s._v(" "),e("p",[s._v("因此，LRU算法适合处理“热点数据”，即被频繁访问的数据，而LFU算法则适合处理“冷门数据”，即不太频繁访问的数据。")]),s._v(" "),e("p",[s._v("了解了上面的两大算法后，有机会可以自己实现一下：")]),s._v(" "),e("p",[s._v("https://leetcode.cn/problems/lru-cache/")]),s._v(" "),e("p",[s._v("https://leetcode.cn/problems/lfu-cache/")]),s._v(" "),e("p",[s._v("TODO: lfu的算法待最后进行实现")]),s._v(" "),e("p",[s._v("random算法")]),s._v(" "),e("p",[e("code",[s._v("allkeys-random")]),s._v(" 和 "),e("code",[s._v("volatile-random")]),s._v("：从所有/过期键中随机选择进行淘汰。")]),s._v(" "),e("p",[s._v("为了更好的查看随机性，我们需要把我们把maxmemory调小一些，之前我们使用的大小是1100K，现在我们使用1030k吧（为什么要调小些？因为之前1100K可以插入2000多条数据，现在我们想看随机性，其实最好插入100多条数据时比较理想的）")]),s._v(" "),e("p",[s._v("对于allkeys-random,经过测试后，确实是在所有的数据当中随机选出key进行淘汰。")]),s._v(" "),e("p",[s._v("如何测试volatile-random呢？")]),s._v(" "),e("p",[s._v("例如我们插入 1 - 100条数据，我们设置过期数据在 10-20之间，那么后期10-20的数据将会被淘汰掉，且会抛出异常。")]),s._v(" "),e("p",[s._v("经过测试，当无限地向redis中插入数据，那么所有的ttl数据key将会被删除，剩下的全都是非过期的数据，这个时候再次插入数据的时候就会抛出异常")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://2290653824-github-io.oss-cn-hangzhou.aliyuncs.com/undefinedimage-20230519142055591.png",alt:"image-20230519142055591"}})]),s._v(" "),e("p",[s._v("怎么测 volatile-ttl")]),s._v(" "),e("p",[s._v("插入1000条可过期数据，过期时间每隔5条设置过期时间为10min，其他过期时间设置为10000min。结果触发策略后，检查每隔5min的key是否被真正的删除了。")]),s._v(" "),e("p",[s._v("结果测试后符合预期，确实每间隔5min就会将其key给删除掉。")])])}),[],!1,null,null,null);e.default=n.exports}}]);