(window.webpackJsonp=window.webpackJsonp||[]).push([[396],{721:function(s,t,a){"use strict";a.r(t);var v=a(4),_=Object(v.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[s._v("#")]),s._v(" 背景")]),s._v(" "),t("p",[s._v("在公司大部分数据库都需要从mongodb迁移到mysql的前提下。现在对某些数据库中的表进行数据迁移。")]),s._v(" "),t("h2",{attrs:{id:"确定要迁移的数据库的数据涉及到的服务有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定要迁移的数据库的数据涉及到的服务有哪些"}},[s._v("#")]),s._v(" 确定要迁移的数据库的数据涉及到的服务有哪些？")]),s._v(" "),t("p",[s._v("首先即要确定我们修改代码的范围，如果所有关于数据库的数据的流量全部来自于同一个服务，那就没有问题，如果数据库的数据访问层可能来自于多个服务，那么问题可能会更复杂一些。以下是关于mongodb数据访问全部来自于一个account服务的解决方案。")]),s._v(" "),t("h2",{attrs:{id:"确定迁移原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定迁移原因"}},[s._v("#")]),s._v(" 确定迁移原因")]),s._v(" "),t("ul",[t("li",[s._v("mongodb在数据量大的情况下，效率较慢。")]),s._v(" "),t("li",[s._v("mongodb维护人员较少，当mongodb发生故障时，很难维护")])]),s._v(" "),t("h2",{attrs:{id:"确定迁移预期目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定迁移预期目标"}},[s._v("#")]),s._v(" 确定迁移预期目标")]),s._v(" "),t("ul",[t("li",[s._v("mongodb数据全量迁移至mysql数据库")]),s._v(" "),t("li",[s._v("迁移过程中不停机，对用户无感")]),s._v(" "),t("li",[s._v("迁移过程中出现问题可以进行降级或回滚。")])]),s._v(" "),t("h2",{attrs:{id:"确定方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#确定方式"}},[s._v("#")]),s._v(" 确定方式")]),s._v(" "),t("p",[s._v("①首先需要考虑mongodb和mysql在数据结构上面的差异，mongodb中的数据结构和mysql差距很多，mongodb中可能会有JSON的格式，需要考虑迁移到mysql中对应的数据结构该怎么设计、索引应该怎么创建。")]),s._v(" "),t("p",[s._v("②考虑中途不宕机，怎实现呢？")]),s._v(" "),t("p",[s._v("思考：该目标是不是可以抽象为两个服务节点之间的数据传输，之前我们学习学习当中的节点间的大量数据传输有哪些呢？比如说redis、mysql，他们在集群下总是会有主副本的区分，主节点要将数据传输到副节点，是不是都实现过一套传输的方案，其方案基本上都是将数据的传输分为存量数据和增量数据的传递。首先我们要确定存量数据如何传输，在存量数据的传递过程中，我们也要进行增量数据的传输，在mysql和redis中，基本的实现方案都是在生成存量传输数据的过程中，接受客户端的请求，然后将增量数据写在一个缓存中，当存量数据传输完成，再将缓存中的数据进行传输。")]),s._v(" "),t("p",[s._v("上面的思考，其实就是在不宕机的情况下，完成数据的传输，其重点就是将数据分为存量数据和增量数据，这时关键，对于存量数据和增量数据如何进行传输，我们可以根据业务具体来实现。")]),s._v(" "),t("p",[s._v("存量数据：在数据开始迁移的那一刻，原数据库所拥有的数据。")]),s._v(" "),t("p",[s._v("增量数据：在数据开始迁移的那一刻，原数据库因为接受到请求新增的数据。")]),s._v(" "),t("p",[s._v("③如何保证出错了过后可以降级？")]),s._v(" "),t("p",[s._v("数据库迁移过程中，想要保证出错可以降级，其本质就是保证mongodb的数据业务上不丢失，与mongodb相关的代码不修改。所以这并不是说在代码版本上的降级，我们应该尽全力保证在数据迁移期间，mongodb的服务（增量数据）依然在进行当中。")]),s._v(" "),t("p",[s._v("如何实现呢？我们可以引入"),t("strong",[s._v("数据双写")]),s._v("和"),t("strong",[s._v("开关")]),s._v("的概念。")]),s._v(" "),t("p",[s._v("数据双写：在迁移过程中，mysql和mongodb都在进行数据的写，这样就算需要降级，mongodb的数据依然存在")]),s._v(" "),t("p",[s._v("开关：如果客户端发送过来读请求，为了保证的数据的"),t("strong",[s._v("一致性")]),s._v("，我们必须保证业务只从一个数据库当中读。那么我们数据迁移过程中，读哪一个呢？")]),s._v(" "),t("p",[s._v("只读mysql：有些数据还在mongodb呢，可能因为读不到而出现错误，所以不能使用mysql")]),s._v(" "),t("p",[s._v("只读mongodb：mongo写同时进行着，那么读肯定是没有问题的。")]),s._v(" "),t("p",[s._v("所以在迁移过程中，我们可以只读mongodb，但是我们不能总读mongodb吧，因为我们的目标就是将mongodb下线，后面总是要将读流量切换到mysql的，而且还要保证不宕机。")]),s._v(" "),t("p",[s._v("这样就引入了开关的概念。")]),s._v(" "),t("p",[s._v("为了我们可以在迁移后平滑地将流量从mongodb切换到mysql，我们在项目中引入开关的概念。并配置在apollo中，通过修改apollo中的开关，动态修改在代码中的实现。")]),s._v(" "),t("p",[s._v("mongodb写开关：为true时，表示开启对mongdb的写")]),s._v(" "),t("p",[s._v("mysql写开关：为true时，表示开启对mysql的写")]),s._v(" "),t("p",[s._v("读开关：为true时，表示开启对mongodb读，否则对mysql读（mongodb读和mysql读是互斥的，所以这里只需要设置这一个互斥开关就可以了）")]),s._v(" "),t("h2",{attrs:{id:"通过上面的方式的思考-我们就可以形成一个大致的实现方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过上面的方式的思考-我们就可以形成一个大致的实现方案"}},[s._v("#")]),s._v(" 通过上面的方式的思考，我们就可以形成一个大致的实现方案")]),s._v(" "),t("p",[s._v("对于存量的数据，我们直接迁移(使用公司内部的"),t("strong",[s._v("工具")]),s._v("：可以将mongodb对应的字段与目标表对应的字段设置相关的映射关系，然后进行数据的迁移）")]),s._v(" "),t("p",[s._v("对于增量数据，采用双写模式写到mysql。")]),s._v(" "),t("p",[s._v("①根据mongodb建立相应的mysql表结构，根据mongodb中repository层编写mysql repository层相关的代码。")]),s._v(" "),t("p",[s._v("②双写上线（读mongo，写mongo、mysql）")]),s._v(" "),t("p",[s._v("③开启dts存量同步(中途开始显现出bug，需要修改)")]),s._v(" "),t("p",[s._v("④存量同步完成后，逐步将读流量切换到Mysql，验证mysql业务逻辑是否有错（bug高峰期）")]),s._v(" "),t("p",[s._v("⑤读流量全量迁移到MySQL并验证完毕后，停止写MongoDB，迁移完成")]),s._v(" "),t("table",[t("thead",[t("tr",[t("th",[s._v("上线阶段")]),s._v(" "),t("th",[s._v("数据库读写状态")]),s._v(" "),t("th",[s._v("流程")]),s._v(" "),t("th")])]),s._v(" "),t("tbody",[t("tr",[t("td",[s._v("MongoDB")]),s._v(" "),t("td",[s._v("MySQL")]),s._v(" "),t("td"),s._v(" "),t("td")]),s._v(" "),t("tr",[t("td",[s._v("一")]),s._v(" "),t("td",[s._v("读/写")]),s._v(" "),t("td",[s._v("写")]),s._v(" "),t("td",[s._v("双写上线，DTS同步存量数据")])]),s._v(" "),t("tr",[t("td",[s._v("二")]),s._v(" "),t("td",[s._v("写")]),s._v(" "),t("td",[s._v("读/写")]),s._v(" "),t("td",[s._v("读流量迁移至MySQL")])]),s._v(" "),t("tr",[t("td",[s._v("三")]),s._v(" "),t("td"),s._v(" "),t("td",[s._v("读/写")]),s._v(" "),t("td",[s._v("停写MongoDB")])])])]),s._v(" "),t("h2",{attrs:{id:"细节思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#细节思考"}},[s._v("#")]),s._v(" 细节思考")]),s._v(" "),t("h3",{attrs:{id:"先考虑双写的具体实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先考虑双写的具体实现"}},[s._v("#")]),s._v(" 先考虑双写的具体实现")]),s._v(" "),t("p",[s._v("读：读我们的第一阶段都是先读mongodb,所以这一点都是毋庸置疑的。")]),s._v(" "),t("p",[s._v("增：增加，表示两个数据库都不存在该数据，所以新增是没有问题的，当做增量数据进行处理。")]),s._v(" "),t("p",[s._v("删：当要删除的数据未同步到mysql中时，mongodb中的数据可以成功删除，mysql因为数据不存在，执行了后语义正确，且后续不会出现该数据；当要删除的数据已经同步到mysql中时，mongodb中的数据可以删除，mysql中的数据也可以删除成功，语义正确")]),s._v(" "),t("p",[s._v("**改：**当要更改的数据（想不清楚了？）")]),s._v(" "),t("p",[s._v("工具思考：应该保证什么功能")]),s._v(" "),t("h3",{attrs:{id:"数据量思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据量思考"}},[s._v("#")]),s._v(" 数据量思考")]),s._v(" "),t("p",[s._v("在进行数据的迁移时，我们必须考虑数据量的大小，是否需要进行分表。因为每个数据库系统，一张表存储的数据量可能不一样，所以我们需要考虑是否要进行分表，如果要进行分表，由要怎么来使用方案，都是要考虑的方案。")]),s._v(" "),t("h3",{attrs:{id:"开关具体实现思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开关具体实现思考"}},[s._v("#")]),s._v(" 开关具体实现思考")]),s._v(" "),t("p",[s._v("我们的重点就是在不宕机的请况下，切换开关。首先我们现在已知的是有3种开关。")]),s._v(" "),t("p",[s._v("读切换开关、mongodb写开关、mysql写开关。")]),s._v(" "),t("p",[s._v("既然要实现机器不宕机，我们就需要对开关实现动态开关。所以我们要借助注册中心，实现对配置文件的动态修改。因为公司对于配置中心使用的也是apollo，所以我们配置中心使用apollo其实也是听不懂的，这样我们在apollo上修改了配置就可以在java代码中及时得到更新。那么我们在springboot中怎么读取这个配置呢？")]),s._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[s._v("    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${mongo2mysqlMigration.reader.mongo}"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Boolean")]),s._v(" mongoReaderEnabled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${mongo2mysqlMigration.writer.mysql}"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Boolean")]),s._v(" mysqlWriterEnabled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[s._v("@Value")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"${mongo2mysqlMigration.writer.mongo}"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("private")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Boolean")]),s._v(" mongoWriterEnabled"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("如图所示，我们使用@Value注解读取yaml文件，当apollo重新更新了配置过后，这里就可以将对应的数据重新注入到成员变量中。")]),s._v(" "),t("p",[s._v("至于@Value注解的原理，可以看看这篇文章https://blog.csdn.net/qq_29717181/article/details/99872792")]),s._v(" "),t("p",[s._v("在代码中，我们就根据开关用if else来对流量进行切换。")]),s._v(" "),t("h3",{attrs:{id:"平滑卸掉mongodb思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#平滑卸掉mongodb思考"}},[s._v("#")]),s._v(" 平滑卸掉mongodb思考")]),s._v(" "),t("p",[s._v("未迁移前我们的代码处于以下这个层次")]),s._v(" "),t("p",[s._v("service层依赖于repository层")]),s._v(" "),t("p",[s._v("service层主要是一些复杂的业务，而repository层主要是直接与数据库交互的层。我们的目的是并不想修改service层的东西，做到对servcie无感。")]),s._v(" "),t("p",[s._v("虽然这个时候就会疑惑了")]),s._v(" "),t("p",[s._v('service中的依赖注解(@Resource(name="UserRepositoryImpl")) 在切换的时候我们不修改这个么？')]),s._v(" "),t("p",[s._v("其实确实不用，我们把mysql的repository 名字改成UserRepositoryImpl，mongodb 的Repository改成其他的就可以了。")]),s._v(" "),t("p",[s._v("这样就可以做到对service层无感知。")]),s._v(" "),t("p",[s._v("这个时候问题又来了，我们有了mysql的repository和mongodb的repository，这个时候怎么做流量的转发呢？这个时候我们要引入另外一个代理层proxy，专门来做我们的代理转发的业务，根据开关配置的真与否来进行流量的分发操作，这个时候我们的框架其实就基本出来了。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/29475739/1675754630646-8a83a8c1-c840-4e6c-82f7-1c8f8b001411.png",alt:"img"}})]),s._v(" "),t("p",[s._v("这时，我们只需要将相关的数据层依赖换为proxy，而proxy又依赖mysql和mongodb就可以实现流量的分发。")]),s._v(" "),t("p",[s._v("以下使我们的各个组件的名字，可以做到对service无感。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2023/png/29475739/1675756975152-25bea9f1-2cb6-43d9-8cda-3e7b448e66a3.png",alt:"img"}})]),s._v(" "),t("p",[s._v("在proxy中根据开关的真假，就可以完成流量的切换了。")]),s._v(" "),t("h3",{attrs:{id:"关注读写界限思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关注读写界限思考"}},[s._v("#")]),s._v(" 关注读写界限思考")]),s._v(" "),t("p",[s._v("mongodb中一些userRepository可能只是纯粹的读或者写，这种对我们是非常友好的，开关切换时就直接切换就好。但是在方法中可能有些不纯粹的操作，比如一个方法中可能既有查询方法，又有修改方法，就感觉向一个service业务方法似得，这种就需要我们手动在proxy中进行拆解，将其中的写方法和读方法正确的进行拆分，这样才不会出错（对于一个不纯粹的方法，如果我们将其定义写操作，那么当我们开启mysql的读时，会执行该方法，那么其中的读mysql操作也会同时执行，这是不符合我们含义的。所以这里我们要划分好读写的界限，要让方法更加纯粹）")])])}),[],!1,null,null,null);t.default=_.exports}}]);