(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{400:function(a,e,v){"use strict";v.r(e);var t=v(4),n=Object(t.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("前言\n首先需要明确的是，以下我们讨论的HotSpot虚拟机，其他类型的虚拟机，例如JRockit与J9等，压根就没有永久代的概念。因此，下面所说的“虚拟机”都是HotSpot版本的。")]),a._v(" "),e("p",[a._v("要想理解这种变化的原因，需要先理解方法区、永久代与元空间的概念与之间的关系。")]),a._v(" "),e("p",[a._v("方法区与永久代，元空间之间的关系\n方法区是一种规范，不同的虚拟机厂商可以基于规范做出不同的实现，永久代和元空间就是出于不同jdk版本的实现。")]),a._v(" "),e("p",[a._v("说白了，方法区就像是一个接口，永久代与元空间分别是两个不同的实现类而已。只不过永久代是这个接口最初的实现类，后来这个接口一直进行变更，直到最后彻底废弃这个实现类，由新实现类——元空间进行替代。")]),a._v(" "),e("p",[a._v("方法区\n借用《深入理解Java虚拟机——JVM高级特性与最佳实践》中介绍方法区的段落")]),a._v(" "),e("p",[a._v("方法区和堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。")]),a._v(" "),e("p",[a._v("Java7及以前版本的永久代的结构\n在Java7及以前的版本，是存在永久代的。在Java7版本时，永久代已经发生了悄悄的变化。等到Java8时，彻底废弃了永久代，由元空间替换。")]),a._v(" "),e("p",[a._v("永久代与堆的构造如下：")]),a._v(" "),e("p",[e("img",{attrs:{src:"C:/Users/zhengjian/AppData/Roaming/Typora/typora-user-images/image-20230727135758586.png",alt:"image-20230727135758586"}})]),a._v(" "),e("p",[a._v("（关于堆中的Eden、from与to区域，可以先参考我的另外一篇文章【JVM】说说java中的堆区）")]),a._v(" "),e("p",[a._v("从上图中可以看到，永久代与堆中的老年代是连续的，这里的连续指的是物理地址连续，永久代本身并不在堆中。因此，老年代与永久代其中一个满了，都会触发Full GC。")]),a._v(" "),e("p",[a._v("我们可以使用以下的命令，来显示指定永久代的大小：")]),a._v(" "),e("p",[a._v('-XX:PremSize：设置永久代的初始大小\n-XX:MaxPermSize: 设置永久代的最大值\n由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出，会报出"java.lang.OutOfMemoryError: PermGen space "异常。')]),a._v(" "),e("p",[a._v("Java7时，永久代的变化\n在Java7时，仍然有永久代，永久代也与堆中的老年代连续，但永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了，比如：")]),a._v(" "),e("p",[a._v("符号引用(Symbols)转移到了Native Memory\n字符串常量池(interned strings)转移到了Java Heap\n类的静态变量(class statics)转移到了Java Heap\n现在分别在Java6、7、8环境中循环调用String.intern()方法（关于此方法，可以先移步到我的另外一篇文章中【JAVA】String源码浅谈，里面有对此方法的介绍与实验），那么分别会报出以下区域的内存溢出异常")]),a._v(" "),e("p",[a._v("Java6时，内存溢出区域为永久代。因为在Java6及之前，字符串常量池在永久代中\nJava7时，内存溢出区域为堆中。因为在Java7时，字符串常量池被移到堆中了。\nJava8时，内存溢出区域仍然为堆中，不过此时已经没有永久代了。\nJava8开始，永久代就已经消失了，由元空间取而代之。")]),a._v(" "),e("p",[a._v("元空间\n元空间(Metaspace)，不再与堆连续，而是直接存在于本地内存中，也就是机器的内存。理论上机器内存有多大，元空间的野心就有多大。但可以通过以下的参数来设置元空间的大小：")]),a._v(" "),e("p",[a._v("-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。\n-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。\n除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：")]),a._v(" "),e("p",[a._v('-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集\n-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集\n在使用-XX:MaxMetaspaceSize显示指定元空间的大小为一个比较小的值，接着在循环中动态加载过多的类，那么会报出"java.lang.OutOfMemoryError: Metaspace"异常。')]),a._v(" "),e("p",[a._v("在Java8时，仍然使用PremSize或MaxPermSize设置永久代的大小时，会被编译器忽略并且警告。")]),a._v(" "),e("p",[a._v("Java8中，使用元空间替换永久代的原因\n在之前的版本中，字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM的异常。此外，JVM加载的class的总数，方法的大小等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。")])])}),[],!1,null,null,null);e.default=n.exports}}]);